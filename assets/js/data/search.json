[ { "title": "(Spring)@ConfigurationProperties", "url": "/posts/(Spring)@ConfigurationProperties/", "categories": "Spring", "tags": "Spring", "date": "2023-11-21 23:13:00 +0900", "snippet": "‼️ Warning- 아래 모든 내용은 제가 공부하며, 작성한 내용이므로 잘못된 내용이 포함될 수 있습니다.- 잘못된 내용에 대해 댓글을 남겨주신다면 정말 감사드리겠습니다. 글 작성 이유스프링을 공부하면서, 유저가 회원가입을 했을때 메일을 통한 인증 관련 로직을 보던 중 예전에 토이 프로젝트를 진행했을때 사용했던 @Value 어노테이션을 사용하여 ya...", "content": "‼️ Warning- 아래 모든 내용은 제가 공부하며, 작성한 내용이므로 잘못된 내용이 포함될 수 있습니다.- 잘못된 내용에 대해 댓글을 남겨주신다면 정말 감사드리겠습니다. 글 작성 이유스프링을 공부하면서, 유저가 회원가입을 했을때 메일을 통한 인증 관련 로직을 보던 중 예전에 토이 프로젝트를 진행했을때 사용했던 @Value 어노테이션을 사용하여 yaml 또는 properties 파일에서 환경 변수 값을 가져오는게 아닌 다른 방식이 있어 정리 하고자 글 작성@Value우선 @Value 어노테이션에 대해 간략하게 알아보자.간단한 예제@Service@Transactional(readOnly = true)public class UserService { private final UserEntityRepository userEntityRepository; private final BCryptPasswordEncoder passwordEncoder; private String secretKey; private Long expiredTimeMs; public UserService(UserEntityRepository userEntityRepository, BCryptPasswordEncoder passwordEncoder, @Value(\"${jwt.secret-key}\") String secretKey, @Value(\"${jwt.expired-time-ms}\") Long expiredTimeMs) { this.userEntityRepository = userEntityRepository; this.passwordEncoder = passwordEncoder; this.secretKey = secretKey; this.expiredTimeMs = expiredTimeMs; } ...}jwt: secret-key: test-secret-key # 30 days expired-time-ms: 25223 예전에 토이 프로젝트를 할때 작성했던 UserService 와 application.yml 코드의 일부분이다. jwt 를 활용하여 유저 로그인 처리를 하고 있는 부분에서 jwt 의 secret-key 와 jwt-expired-time 을 @Value 어노테이션을 통해 외부에서 가지고와 활용을 하고 있다. @Value 어노테이션의 경우 필드, 메서드, 파라미터, 어노테이션에 붙여 사용이 가능하다. 위 코드에서는 파리미터에 붙여서 사용하고 있다. 추가적으로 스프링에서 제공하는 SpEL 도 사용이 가능하며, SpEL 사용 시 동적으로 값을 매핑해줄수 있다.동작 원리 @Value 를 사용한 곳에 값이 매핑 되는 시점은 Bean 이 생성되고 의존성이 주입되는 시점에 값이 매핑된다.장점 사용이 매우매우 편리하다. 별도의 설정 없이 @Value 어노테이션만 사용하여 값을 가져올 수 있다.단점 구글에 검색해 보면 @Value 어노테이션을 활용하여, 값을 가져올때 값을 가져오지 못하고 null 값이 나온다는 내용이 매우 많다. 어느 시점에 값이 매핑되는지 정확하게 알고 있는것이 중요할것 같다. application.yml 파일에서 key 에 해당하는 값이 변경되는 경우 @Value 가 사용된 모든 곳에 값을 변경해야하는 번거로움이 있다.@ConfigurationProperties @Value 어노테이션 과 비슷하게 외부의 값을 가져올때 사용할 수 있다. 스프링 팀에서 권장하는 방법@ConfigurationProperties(prefix = \"spring.jpa\")public class JpaProperties { ...}@ConfigurationProperties(prefix = \"spring.data.redis\")public class RedisProperties { ...} 위 코드에서 보이듯 Jpa 설정 값이나 Redis 설정 값 등등 우리가 application.yml 에서 설정해주는 외부 값을 @ConfigurationProperties 어노테이션을 사용해 가져오는걸 확인할 수 있다.간단한 예제 이번에는 JavaMailSender 를 Bean 으로 등록 하고 사용할때 외부에서 값을 넣어줘야 하는 부분이 있어 사용하게 되었다.@ConfigurationProperties(prefix = \"spring.mail\")public record MailSetting(String host, int port, String username, String password) {}@ConfigurationProperties(prefix = \"spring.mail.properties.mail.smtp\")public record MailProperties(boolean auth, boolean starttls, int timeout) {} 총 두개의 record 에서 @ConfigurationProperties 어노테이션을 통해 값을 가져와 사용하고 있다. 생성자 바인딩이 가능하여, record 와 사용했을때 매우 편리하게 사용이 가능하다. 만약 생성자가 여러개의 경우 @ConstructorBinding 어노테이션을 사용하여 바인딩할 생성자를 선택할 수 도 있다. 또 추가로 @DefaultValue(value=defaultValue) 어노테이션을 사용해 기본값을 넣어줄 수 도 있다. 다만 @ConfigurationProperties 을 사용할때 어노테이션을 활성화 시켜줘야하는 부분이 있어 이점에 유의해야한다.@SpringBootApplication@ConfigurationPropertiesScanpublic class MyApplication { public static void main(String[] args) { SpringApplication.run(MyApplication.class, args); }} 일반적으로 Spring 프로젝트를 생성했을때 만들어지는 main 메서드를 가지는 클래스 위에 @ConfigurationPropertiesScan 어노테이션을 붙여 사용가능하게끔 활성화 시킨다. @ConfigurationPropertiesScan 어노테이션을 사용할때 패키지 경로를 선언하여, 해당 패키지 경로에 있는 @ConfigurationProperties 어노테이션만 활성화 되도록 만들 수도 있다.장점 Relaxed Binding 사용이 가능하다. Relaxed Binding: application.yml 과 바인딩 되는 값의 이름이 정확하게 일치하지 않더라도 바인딩을 해주는 방법 ex: PORT 와 port 는 대소문자로 차이가 있지만 @ConfigurationProperties 어노테이션을 사용하면 바인딩이 가능하다. 위 예제 외에 몇가지 완화된 규칙을 가지고 바인딩을 해주기 때문에 편리하게 사용이 가능하며, 자세한 내용은 아래 공식 문서에서 확인이 가능하다. 메타데이터를 지원한다.단점 SpEL 의 사용이 불가능하다.(단점 맞나??) 처음 사용할때 초기 설정이 필요하다. 활성화와 바인딩을 위한 객체 생성 등 @Value 와 @ConfigurationProperties 차이차이표 특징 @ConfigurationProperties @Value Relaxed binding O 부분적 지원 Meta-data support O X SpEL evaluation X O 선택 기준 공식 문서에서는 @ConfigurationProperties 어노테이션을 사용한 POJO 를 통해 그룹화 하는것을 권장하고 있으며, 만약 SpEL 을 사용하여 값을 처리해야 경우에 @Value 를 사용하면 좋다고 한다.REFERENCE SpringApplication Docs" }, { "title": "(Algorithm)유클리드 호제법", "url": "/posts/(Algorithm)%EC%9C%A0%ED%81%B4%EB%A6%AC%EB%93%9C-%ED%98%B8%EC%A0%9C%EB%B2%95/", "categories": "Algorithm", "tags": "Algorithm", "date": "2023-05-23 12:47:00 +0900", "snippet": "유클리드 호제법? 두개의 자연수에 대한 최대 공약수를 구하는 알고리즘원리 두 수의 자연수 x 와 y 에 대해 두 수를 나눈 나머지를 z 라고 했을때, x 와 y 의 최대 공약수는 y 와 z 의 최대 공약수와 같다. 위에 논리를 이용해서 x 와 y 의 나머지 z 를 구한 뒤 y 와 z 의 나머지 z' 를 구하여, y 와 z' 를 계속 나누다 나머지...", "content": "유클리드 호제법? 두개의 자연수에 대한 최대 공약수를 구하는 알고리즘원리 두 수의 자연수 x 와 y 에 대해 두 수를 나눈 나머지를 z 라고 했을때, x 와 y 의 최대 공약수는 y 와 z 의 최대 공약수와 같다. 위에 논리를 이용해서 x 와 y 의 나머지 z 를 구한 뒤 y 와 z 의 나머지 z' 를 구하여, y 와 z' 를 계속 나누다 나머지가 0 이 되는 순간의 z' 의 값이 최대 공약수 가 된다.예2, 16의 최대 공약수 1) 12 % 16 = 12 2) 16 % 12 = 4 3) 12 % 4 = 0 4) 최대 공약수 = 4 JAVA CODE 재귀와 유클리드 호제법을 사용해서 최대 공약수를 구하는 코드를 짜보자.public class GCD { public static void main() { int x = 12; int y = 16; int gcd = getGCD(x, y); System.out.println(\"gcd: \" + gcd); } public static void getGCD(x, y) { if (x % y == 0) { return y; } return getGCD(y, x%y); }}최소 공배수는? 최소 공배수(LCM): (x * y) / 최대 공약수(GCD) 위에 공식을 활용하면 최대 공약수(GCD) 를 활용해서 최소 공배수(LCM) 도 쉽게 구할 수 있다.자연수가 3개 이상일때는? 자연수 x, y, z 가 있다고 한다면, 먼저 x와 y 의 최대 공약수(GCD) 인 f 를 구한 뒤 f와 z 의 최대 공약수(GCD) 를 구하면 된다.간단한 문제 프로그래머스에서 최대 공약수와 최소 공배수를 구하는 문제를 하나 풀어보자. class Solution { public int[] solution(int n, int m) { int[] answer = new int[2]; int gcd = recursionFunction(n, m); int lcm = n * m / gcd; answer[0] = gcd; answer[1] = lcm; return answer; } public int recursionFunction(int n, int m) { if (n % m == 0) { return m; } return recursionFunction(m, n % m); }} REFERANCE유클리드 호제법" }, { "title": "(Seminar)제어할 수 없는 것에 의존하지 않기", "url": "/posts/(Seminar)%EC%A0%9C%EC%96%B4%ED%95%A0-%EC%88%98-%EC%97%86%EB%8A%94-%EA%B2%83%EC%97%90-%EC%9D%98%EC%A1%B4%ED%95%98%EC%A7%80-%EC%95%8A%EA%B8%B0/", "categories": "Seminar", "tags": "Seminar", "date": "2023-04-23 23:10:00 +0900", "snippet": "글을 작성하게 된 이유얼마 전 업무를 진행하면서, 우아한테크세미나 에서 들었던 내용중 이동욱님이 이야기 해주신 내용에 매우 공감하는 부분이 있어 정리하면서 추후 이와같은 실수를 방지하기 위해 작성제어 할 수 없는 것에 의존하지 않기간략한 내용이동욱님 께서 제어할 수 없는것에 의존하지 않기 라는 제목으로 발표를 해주셨는데, 발표 내용중 DB의 PK 값...", "content": "글을 작성하게 된 이유얼마 전 업무를 진행하면서, 우아한테크세미나 에서 들었던 내용중 이동욱님이 이야기 해주신 내용에 매우 공감하는 부분이 있어 정리하면서 추후 이와같은 실수를 방지하기 위해 작성제어 할 수 없는 것에 의존하지 않기간략한 내용이동욱님 께서 제어할 수 없는것에 의존하지 않기 라는 제목으로 발표를 해주셨는데, 발표 내용중 DB의 PK 값으로 예전에는 주민등록 번호를 종종 사용하였는데 이 부분이 법적으로 수집이 불가능해지면서 사용하는 모든 DB 의 PK 값을 변경해야하는 대대적인 작업을 진행한적이 있다고 말씀해주시면서 의존할 수 없는 것(여기서는 주민번호) 에 의존하게 되면 그 부분에 있어 변경이 발생하는 경우 들어가는 리소스가 매우 많아져서 곤란할 수 있다는 내용이 있었다.공감된 부분최근 회사에서 여러 사이트를 통합으로 모니터링 하는 사이트를 운영하고 새로운 기능을 추가하는 부분을 업무로 맡았는데, 여기서 여러 사이트를 구분할때 사이트 마다 하나씩 설치되어있는 어떤 장치의 고유 번호를 사용하고 있었다. 근대 여기서 문제가 발생하였는데 바로 이 장치가 각 사이트에 두개 이상이 설치될 수 있다는 부분이였다. 원래는 각 사이트마다 하나씩만 설치되어 운영될 예정이였는데 이 부분이 변경되면서 문제가 발생하게 되었다.url = www.example.com?고유번호=xxx위 방식으로 각 사이트의 URL 을 구분하고 있었는데, 이게 고유 번호가 두개 이상 들어가면서 고유 번호로 사이트를 구분하는데 문제가 발생하게 된것이다.게다가 동욱님 사례와 유사하게 이 고유 번호를 가지고 DB 의 PK 를 설정하여 값을 저장하고 꺼내오고 있었는데 식별이 어려워 지면서 모든DB 의 사이트 PK 를 변경해야 하는 문제도 함께 발생하게 되었다.기존에 사용하던 고유번호의 경우 우리가 제어할 수 있는 번호가 아니라 각 장치의 번호이기도 하면서, 우리가 무조건 하나만 설치하고 사용할수 있는것 도 아니였다. 즉 제어할수 없는 부분이 2개씩이나 있는 번호를 우리는 지금까지 각 사이트의 구분에 사용하고 있었던것이다.url = www.example.com?site_id=xxx결국 나는 사이트를 구분하는 값을 변경할 수 밖에 없었다. 그래서 각 사이트 마다 우리가 정해준 id 값을 사용하여 구분하도록 변경하였다.변경 작업이 간단하고 쉽지많은 않았다. 모든 코드의 URL 을 사이트 고유의 id 로 변경을 해야했고, DB 의 PK 를 변경해야하는 작업 까지 함께 진행했기 때문이다.데이터가 몇개 없더라도 PK 를 변경하는것은 쉽지 않은 작업인데, 실제 운영하는 DB 의 PK 를 변경하는 작업은 정말정말 쉽지 않았고 고려해야할 내용도 매우 많았다.물론 서비스를 처음 내가 만들것은 아니였지만, 이동욱님의 발표를 듣기 전의 나였더라면 어떤 선택을 했을까? 라는 생각을 해봤다.앞으로 코드를 작성하고 설계하면서 내가 스스로 제어 할 수 없는 부분에 의존하고 있는 부분은 없는지 좀 더 확인하고 생각하면서 코드를 작성과 설계를 해야겠다는 생각이 들었다.REFERENCE [우아한테크세미나] 테크 리더 3인이 말하는 “개발자 원칙”" }, { "title": "(Python)Python 가상환경 설정", "url": "/posts/(Python)Python-%EA%B0%80%EC%83%81%ED%99%98%EA%B2%BD-%EC%84%A4%EC%A0%95/", "categories": "Python", "tags": "Python", "date": "2023-01-22 23:22:00 +0900", "snippet": "Python 가상환경 설정 Java Spring 만 사용하다, 이번에 새롭게 Python 과 Django 를 배우고 있는데 무엇을 하던지 새로운 환경을 설정하는것은 어렵고 오래걸리는것 같다. 매번 여기저거 검색해서 찾아 다니는 것보단 내가 정리를 해놓는게 더 좋을 것 같아 글을 쓰게 되었다.가상환경 설정이 필요한 이유 Java 를 사용할때도 jen...", "content": "Python 가상환경 설정 Java Spring 만 사용하다, 이번에 새롭게 Python 과 Django 를 배우고 있는데 무엇을 하던지 새로운 환경을 설정하는것은 어렵고 오래걸리는것 같다. 매번 여기저거 검색해서 찾아 다니는 것보단 내가 정리를 해놓는게 더 좋을 것 같아 글을 쓰게 되었다.가상환경 설정이 필요한 이유 Java 를 사용할때도 jenv 를 사용해서 java 의 버전을 프로젝트마다 따로 설정해서 사용하긴 했는데, Python의 경우에도 프로젝트마다 버전을 달리 사용해야 하는경우도 있고, 프로젝트 마다 필요한 라이브러리들이 다르고 그걸 통합해서 관리하는 것 보단 나눠서 관리하는게 더 편리하다고 느껴 가상환경을 설정해 사용하기로 했다.가상환경 설정 방법pyenv 와 virtualenv 를 사용한 방법 우선 pyenv 를 맥에 설치한다. brew install pyenv 명령어 사용 설치 후 ~/.zshrc 에 설정해줘야 하는것이 있는데 homebrew 사이트에 자세히 나와있어 따라하기만 하면 된다. 가상 환경 설정을 위해 pyenv-virtualenv 를 맥에 설치한다. brew install pyenv-virtualenv 명령어 사용 프로젝트에 사용할 버전의 Python 을 설치해 준다. pyenv install --list | grep 3. 3번때 버전의 Python 의 설치 가능 버전을 확인 pyenv install 3.11.1 Python 3.11.1 버전 설치 설치한 버전을 사용해서 가상환경을 만든다. pyenv virtualenv 3.11.1 py3.11 3.11.1 버전을 가지고 py3.11 이라는 이름을 가지는 가상환경 생성 프로젝트를 진행할 root 디렉토리로 이동 프로젝트 디렉토리에 가상환경 적용 pyenv local py3.11 명령어 사용 터미널 명령어줄 앞 또는 뒤에 (py3.11) 이 붙어 가상환경이 적용된걸 확인할 수 있다. 필요한 라이브러리 다운로드 받아 사용 pip3 freeze 다운받은 라이브러리 확인 다른 가상환경을 적용시켜 보면 방금 환경에서 설치한 라이브러리가 검색되지 않는걸 알 수 있다.(프로젝트 별로 필요한 라이브러리를 따로 관리할 수 있게 된다.) - .python-version 파일이 생성되며 이 파일로 Python 을 실행할때 해당 환경의 Python 을 사용하게끔 해준다. venv 를 사용한 설정 방법 pyenv 또는 homebrew 를 통해 Python 설치가 필요하다. venv 가 Python 에서 제공하는 라이브러리이기 때문에 우선 Python 설치가 필요 프로젝트를 진행할 root 디렉토리로 이동 프로젝트 디렉토리에서 프로젝트에 사용할 가상환경 생성 python -m venv .venv .venv 라는 이름의 가상환경 생성 python 버전의 경우 pyenv 로 설정한 global 버전 또는 맥에 설치한 Python 버전을 따라간다. 가상환경 활성 가상환경을 생성하면 가상환경의 이름과 동일한 디렉토리가 생성된다. source .venv/bin/activate 명령어를 통해 가상환경을 활성화 시킬 수 있다. .venv 디렉토리 안에 가상환경에서 사용할 python 이 생성되기 때문에 which pyton 명령어를 통해 가상환경이 설정 되었는지 알 수 있다. 가상환경 비 활성 deactivate 명령어를 통해 가상환경을 비 활성 시킬 수 있다. 각각의 설정 방법에 대한 장, 단점pyenv 와 virtualenv 를 사용한 방법장점 가상환경이 비활성화 될 일이 거의 없다. .pytion-version 파일을 삭제하는 경우는 거의 드물기 때문 단점 Python 외에 vritualenv 를 설치해서 사용해줘야 한다. 처음 설정하는것이라면 조금 헤맬수도 있다.venv 를 사용한 방법장점 따로 설치할 필요 없이 Python 만 있으면 가상환경일 설정하고 사용할 수 있다.(편리하다.)단점 맥을 재부팅하면 가상환경이 비활성화 된다. 가상환경이 비활성화 되었을때 그걸 모르고 라이브러리 설치 를 진행하면 프로젝트에서 import 가 안되는 문제가 발생할 수 있다. 매번 가상환경이 활성화 되어 있는지 신경써줘야 한다. 처음 사용하는 사람의 경우 가상환경이 아닌 다른곳에 라이브러리를 설치하는 등의 실수가 있을수 있다. " }, { "title": "(Spring)@ModelAttribute", "url": "/posts/(Spring)@ModelAttribute/", "categories": "Spring", "tags": "Spring", "date": "2022-12-16 12:30:00 +0900", "snippet": "@ModelAttribute글을 작성하게 된 이유 N 사 모 카페에서 질문 글을 읽어 보던 중, 내가 생각했던 해결방법과 작성자께서 해결하신 해결 방법이 달라 헷갈렸던 내용을 정리하면서, @ModelAttribute 에 대해 정확하게 알고자 작성하게 되었다. 질문 내용으로는 Form 형식으로 데이터를 전송하는 중에 Dto 를 사용해서 전송된 값을 ...", "content": "@ModelAttribute글을 작성하게 된 이유 N 사 모 카페에서 질문 글을 읽어 보던 중, 내가 생각했던 해결방법과 작성자께서 해결하신 해결 방법이 달라 헷갈렸던 내용을 정리하면서, @ModelAttribute 에 대해 정확하게 알고자 작성하게 되었다. 질문 내용으로는 Form 형식으로 데이터를 전송하는 중에 Dto 를 사용해서 전송된 값을 Controller 에서 받고 있는데 그 값이 null 로 들어온다는 내용이였다.헷갈렸던 내용@Controllerpublic class Test { @RequestMapping(value = \"/create\", method = RequestMethod.POST) public String hospicreate(HosSaveRequestDto dto) { ... return \"redirect:/\"; }} HosSaveRequestDto 를 통해서 Form 에서 전달된 데이터를 받고있는데, 여기서 dto 내부의 값이 null 로 받아지는 문제가 발생하고 있었다.@Getter@NoArgsConstructorpublic class HosSaveRequestDto { private Long id; private String name; private String address; @Builder public HosSaveRequestDto(Long id, String name, String address) { this.id = id; this.name = name; this.address = address; } public Hospital toEntity() { return Hospital.builder() .id(id) .name(name) .address(address) .build(); } @Override public String toString() { return \"name::\" + this.getName() + \"address::\" + this.getAddress(); }} Dto 내부의 모습 내가 생각했던 해결 방법으로는, @ModelAttribute 어노테이션이 빠져서 이런 문제가 발생하는 것이라 생각했었다. 작성자께서 해결하신 방법은 Dto 에 @Setter 어노테이션을 달아 모든 필드값에 대한 Setter 를 만들어 해결 하셨다. 처음 해결하셨다는 글을 보고 매우 당황했다. 내가 알기로는 Setter 가 필요가 없을텐데 왜? Setter 를 만들어 줌으로 해결이 되었을까? 내가 잘못알고 있던 내용이 많은것 같아 공부하고 정리하기로 했다.사용방법@Target({ElementType.PARAMETER, ElementType.METHOD})@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface ModelAttribute { ...} @ModelAttribute 는 Parameter 와 Method 두 가지 방식을 지원한다.Method@Controllerpublic class Test { @RequestMapping(value = \"/create\", method = RequestMethod.POST) public String hospicreate(@ModelAttribute HosSaveRequestDto dto) { ... return \"redirect:/\"; } @ModelAttribute public void modelAttributeMethodTest() { System.out.println(\"method attribute\"); }} Controller 에서 Method 에 명시하여 사용하면 된다. Method 에 @ModelAttribute 를 명시하여 사용할 경우 hospicreate Method 전에 @ModelAttribute 가 명시되어 있는 Method 가 먼저 실행되게 된다.Parameter@Controllerpublic class Test { @RequestMapping(value = \"/create\", method = RequestMethod.POST) public String hospicreate(@ModelAttribute HosSaveRequestDto dto) { ... return \"redirect:/\"; }} Controller 에서 파라미터 부분에 명시하여 사용하면 된다.동작원리순서 생성자를 찾아서 인스턴스를 생성한다. public 으로 선언되어 있는 생성자를 찾는다. 만약 생성자가 없다면, public 이 아닌 생성자중 인자가 제일 적은 생성자를 선택 찾은 생성자가 1개라면, 해당 생성자를 선택 찾은 생성자가 여러 개라면, 인자수가 제일 적은 생성자를 선택 선택된 생성자를 사용해 인스턴스를 만들 때 생성자의 인자의 이름 중 클라이언트가 요청한 파라미터의 이름과 같은 것이 있다면 해당 인자에 요청한 파라미터의 값을 넣어서 생성 클라이언트가 요청한 파라미터 기준으로 setter 메서드를 찾아서 setter 메서드를 찾아서 실행상세 @ModelAttribute 의 경우 ModelAttributeMethodProcessor 클래스 내부에서 대게 진행되며, constructAttribute 라는 이름의 메서드 내부에서 생성자를 찾는 동작이 이뤄진다. public class ModelAttributeMethodProcessor implements HandlerMethodArgumentResolver, HandlerMethodReturnValueHandler { protected Object constructAttribute( Constructor&lt;?&gt; ctor, String attributeName, MethodParameter parameter, WebDataBinderFactory binderFactory, NativeWebRequest webRequest) throws Exception { if (ctor.getParameterCount() == 0) { // A single default constructor -&gt; clearly a standard JavaBeans arrangement. return BeanUtils.instantiateClass(ctor); } ... }} 내부 로직이 매우 복잡 하지만, 하나씩 살펴본다면 위의 Dto(HosSaveRequestDto) 처럼 인자가 0개의 기본 생성자만 가지고 있는 경우라면, 여기서 보이는 if 문에 의해서 BeanUtils.instantiateClass(ctor) 로 넘어가게 된다. 여기서 setter 가 있는 경우와 없는 경우로 나뉘게 되는데.@Getter@NoArgsConstructorpublic class HosSaveRequestDto { private Long id; private String name; private String address; @Builder public HosSaveRequestDto(Long id, String name, String address) { this.id = id; this.name = name; this.address = address; } ... public void setName(String name) { this.name = name; }} 이 처럼 setter 가 있을 경우 setter 를 이용해서 값을 넣어주게 된다. 만약 setter 가 없고 인자가 제일 적은 생성자가 기본 생성자일 경우 어떠한 값도 바인딩 시키지 못해 값을 넣어주지 못하게 된다.@Getterpublic class HosSaveRequestDto { private Long id; private String name; private String address; @Builder public HosSaveRequestDto(Long id, String name, String address) { this.id = id; this.name = name; this.address = address; } ...} 위의 경우 처럼 3개의 인자를 갖는 생성자가 유일한 생성자의 경우 생성자를 통해 값이 바인딩 되기 때문에 문제 없이 값이 잘 받아지게 된다.생략 가능public class ModelAttributeMethodProcessor implements HandlerMethodArgumentResolver, HandlerMethodReturnValueHandler { @Override\tpublic boolean supportsParameter(MethodParameter parameter) {\t\treturn (parameter.hasParameterAnnotation(ModelAttribute.class) ||\t\t\t\t(this.annotationNotRequired &amp;&amp; !BeanUtils.isSimpleProperty(parameter.getParameterType())));\t}} SimpleValueType 이 아니면서, Argument Resolver에 등록되어 있지 않는 경우 @ModelAttribute 가 사용된다. 즉, Parameter 의 Type 복합 타입일 경우 생략하여도 @ModelAttribute 가 동작하기 때문에 생략이 가능하다. 단, 코드의 가독성이나 추후 유지보수를 생각한다면 생략하는것 보다 명시해주는것이 좋다.정리 위에 질문에 대해 해결하는 방법으로는 두 가지가 있다는걸 알게되었다. 첫번째로는 setter 를 사용하는 방법 Dto 라 크게 문제되지 않을것 같지만, 그래도 무분별한 setter 의 사용은 지양하는 편이 좋다. 두번째로는 생성자 를 사용하는 방법 단, form 에서 넘겨주는 name 의 값과 생성자에 인자값의 이름과 동일하게 맞춰줘야 하며 2개 이상의 생성자가 있는 경우 주의해서 사용해줘야 한다. 위에 질문에서 가장 큰 문제점은 생성자를 2개 사용하는데 그 중 하나로 기본생성자를 사용하고 있다는 문제인것 같다. 만약 기본생성자를 절대적으로 사용해야만 한다면 바인딩 해줘야하는 필드값에 대해 setter 를 만들어주어야 할것 같다." }, { "title": "(Book)DAO의 분리와 확장(토비의 스프링)", "url": "/posts/(Book)DAO%EC%9D%98-%EB%B6%84%EB%A6%AC%EC%99%80-%ED%99%95%EC%9E%A5(%ED%86%A0%EB%B9%84%EC%9D%98-%EC%8A%A4%ED%94%84%EB%A7%81)/", "categories": "Book", "tags": "Book", "date": "2022-11-15 11:52:00 +0900", "snippet": "DAO의 분리와 확장초난감 DAO DAO: DB를 사용해 데이터를 조회하거나, 조작하는 기능을 전담하도록 만든 오브젝트 자바 빈: 두 가지의 관례를 따라 만들어진 오브젝트 디폴트 생성자: 자바 빈 은 파라미터가 없는 디폴트 생성자를 가지고 있어야 한다.(툴 또는 프레임워크 에서 리플렉션을 사용하여 오브젝트를 만들기 위해) ...", "content": "DAO의 분리와 확장초난감 DAO DAO: DB를 사용해 데이터를 조회하거나, 조작하는 기능을 전담하도록 만든 오브젝트 자바 빈: 두 가지의 관례를 따라 만들어진 오브젝트 디폴트 생성자: 자바 빈 은 파라미터가 없는 디폴트 생성자를 가지고 있어야 한다.(툴 또는 프레임워크 에서 리플렉션을 사용하여 오브젝트를 만들기 위해) 프로퍼티: 자바 빈 이 노출하는 이름을 가진 속성, 프로퍼티는 set 으로 시작하는 수정 메서드와 get 으로 시작하는 접근자 메서드를 사용해 수정 또는 조회가 가능하다. Userpublic class User { String id; String name; String password; public String getId() { return id; } public void setId(String id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; }} id, name, password 프로퍼티를 가지고 있는 User 오브젝트 get, set 이 붙은 메서드틀 통해 조회와 수정이 가능하다. 즉 위에 오브젝트가 앞에서 설명한 자바 빈 이라고 할 수 있다.UserDAOpublic class UserDao { public void add(User user) throws ClassNotFoundException, SQLException { Class.forName(\"com.mysql.cj.jdbc.Driver\"); Connection c = DriverManager.getConnection( \"jdbc:mysql://localhost:3306/toby_spring\" ); PreparedStatement ps = c.prepareStatement( \"insert into users(id, name, password) values (?, ?, ?)\" ); ps.setString(1, user.getId()); ps.setString(2, user.getName()); ps.setString(3, user.getPassword()); ps.executeUpdate(); ps.close(); c.close(); } public User get(String id) throws ClassNotFoundException, SQLException { Class.forName(\"com.mysql.cj.jdbc.Driver\"); Connection c = DriverManager.getConnection( \"jdbc:mysql://localhost:3306/toby_spring\" ); PreparedStatement ps = c.prepareStatement( \"select * from users where id = ?\" ); ps.setString(1, id); ResultSet rs = ps.executeQuery(); rs.next(); User user = new User(); user.setId(rs.getString(\"id\")); user.setName(rs.getString(\"name\")); user.setPassword(rs.getString(\"password\")); rs.close(); ps.close(); c.close(); return user; }} User 오브젝트를 DB 에 넣고 관리하는 DAO 오브젝트 여담으로 코드스쿼드에서 순수 JDBC를 사용한 프로젝트를 진행할때 작성했던 코드와 매우 유사하다. 조금은 반가웠다 ㅋ.ㅋ 위에 작성된 코드를 현업 개발자가 작성하였다면 쫒겨났을꺼라는 토비님의 말씀이 있었다. 위에 코드가 어떤점이 문제인지, 이를 개선하면 앞으로 어떤 측면에서 좋은점을 갖는지 이걸 고민하는게 스프링을 공부하는 방법이라 한다.public static void main(String[] args) throws ClassNotFoundException, SQLException { UserDao userDao = new UserDao(); User user = new User(); user.setId(\"crispin\"); user.setName(\"crispindeity\"); user.setPassword(\"molru\"); userDao.add(user); System.out.println(\"등록 성공 = \" + user.getId()); User user2 = userDao.get(user.getId()); System.out.println(\"user2.getName() = \" + user2.getName()); System.out.println(\"user2.getPassword() = \" + user2.getPassword()); System.out.println(\"조회 성공 = \" + user2.getId());} 위에 작성한 UserDao 오브젝트가 정상적으로 동작하는지 확인해보는 테스트용 main 메서드 물론 우리가 생각했던대로 등록과 조회가 매우 잘 되는걸 알 수 있다. 하지만, 기능이 잘 된다 해서 좋은 코드는 아니라는것DAO의 분리관심사의 분리 관심이 같은 것 끼리는 하나의 객체 안으로 또는 친한 객체로 모이게 하고, 관심이 다른것은 가능한 한 따로 떨어져서 서로 영향을 주지 않도록 분리해야한다. 만약 관심사를 따로 분리하지 않는다면, 어떠한 요구사항에 있어 변경이 일어나게 되면 코드에 많은 변경이 발생하게 된다.UserDao 의 관심사항 DB 와 연결을 위한 커넥션을 어떻게 가져올까 라는 관심 더 세부적으로 어떤 DB 를 사용하고, 어떤 드라이버를 사용하며, 어떤 로그인 정보를 쓰고, 그 커넥션은 어떻게 만들것인지 이렇게 더 세부적으로 관심사를 분리 시킬수도 있다. 사용자 등록을 위해 DB 에 보낼 SQL 문장을 담을 statement 를 만들고 실행하는 관심 어떤 SQL 을 사용할지와, 파라미터를 어떻게 바인딩 시킬지 이것도 다른 관심사로 분리가 가능하다. 공유 리소스를 반환하는 관심중복 코드의 메서드 추출public void add(User user) throws ClassNotFoundException, SQLException { Connection c = getConnection(); ...}public void get(String id) throws ClassNotFoundException, SQLException { Connection c = getConnection(); ...}private Connection getConnection() throws ClassNotFoundException, SQLException { Class.forName(\"com.mysql.cj.jdbc.Driver\"); Connection c = DriverManager.getConnection( \"jdbc:mysql://localhost:3306/toby_spring\" ); return c;} 커넥션을 가져오는 부분의 관심을 getConnection() 메서드로 분리하였다. 앞으로 DB 가 변경되어 커넥션을 변경해야 하면 다른 메서드는 건드릴 필요없이 getConnection() 메서드만 변경하면 되어, 수정이 매우 편리해졌다.상속을 통한 UserDao 확장 각기 다른 형식으로 커넥션을 만들 필요가 발생하였을때, getConnection() 메서드만 변경하여 각기 다른 커넥션을 만들 수 있도록 상속을 통해 UserDao 를 확장시켜 보자.public abstract class UserDao { public void add(User user) throws ClassNotFoundException, SQLException { Connection c = getConnection(); ... } public User get(String id) throws ClassNotFoundException, SQLException { Connection c = getConnection(); ... } public abstract Connection getConnection() throws ClassNotFoundException, SQLException;} UserDao 를 추상클래스로 만들어 get() 과 add() 의 메서드는 기존의 로직대로 되어있고, 필요에따라 커넥션을 만드는 메서드만 따로 구현하여 사용할 수 있게 만든다.public class NUserDao extends UserDao { @Override public Connection getConnection() throws ClassNotFoundException, SQLException { // N DB 커넥션 생성코드 ... }}public class DUserDao extends UserDao { @Override public Connection getConnection() throws ClassNotFoundException, SQLException { // D DB 커넥션 생성코드 ... }} 위와 같이 두 가지의 다른 커넥션을 만들어야 할때 UserDao 객체 는 어떠한 수정도 필요없이, UserDao 를 상속받아서 구현만 하면 된다. 즉, 어떻게 데이터를 DB 에 등록하고, 등독되어 있는 데이터를 가져올것인가 에 대한 관심을 갖고있는 UserDao와 DB 연결 방법을 어떻게 할 것인가 에 대한 관심을 갖고있는 NUserDao, DUserDao 가 클래스 레벨로 구분이 되고 있다. 변경이 쉽다라는 수준을 넘어서 이제는 확장까지 손 쉽게 해결할 수 있는 단계가 되었다.상속을 통한 UserDao 확장 단점 상속을 통해 관심이 다른 기능을 분리하였지만, 상속관계는 두 가지의 다른 관심사에 대해 긴밀한 결합을 허용한다. 서브 클래스의 경우 슈퍼 클래스의 기능을 그대로 사용이 가능하기 때문에 슈퍼 클래스의 변경이 있을 경우 모든 서브 클래스의 수정이 불가피 하다. 확장된 기능인 DB 커넥션을 생성하는 코드를 다른 DAO 클래스에 적용 시킬 수 없다. UserDao 외에 DAO 클래스가 계속 만들어진다면 상속을 통해 만들어진 getConnection() 메서드의 구현 코드가 매 DAO 클래스 마다 중복돼서 나타날수 있다.DAO의 확장클래스의 분리 상속을 활용하여 관심사를 분리하는 것이 아니라 그냥 클래스 자체를 나눠서 관심사를 분리시켜 보자. public class UserDao { private SimpleConnectionMaker simpleConnectionMaker; public UserDao(SimpleConnectionMaker simpleConnectionMaker) { this.simpleConnectionMaker = simpleConnectionMaker; } public void add(User user) throws ClassNotFoundException, SQLException { Connection c = simpleConnectionMaker.getConnection(); ... } public User get(String id) throws ClassNotFoundException, SQLException { Connection c = simpleConnectionMaker.getConnection(); ... }} 생성자 주입을 통해 simpleConnectionMaker 를 주입 받아 변수에 저장하여, 메소드에서 사용하면 된다.public class SimpleConnectionMaker { public Connection getConnection() throws ClassNotFoundException, SQLException { Class.forName(\"com.mysql.cj.jdbc.Driver\"); Connection c = DriverManager.getConnection( \"jdbc:mysql://localhost:3306/toby_spring\" ); return c; }} 상속을 할 필요가 없으니 메서드는 abstract 로 만들 필요도 없다. 기존의 코드가 많이 변경되었지만, 기능상의 변경은 전혀 없다. 관심사의 경우는 완벽하게 분리가 되었지만, 이전 처럼 여러 DB 커넥션을 생성하려 한다면 UserDao 의 수정 없이 되는 것이 아니라, UserDao 가 수정되게 된다.인터페이스의 도입 클래스를 분리하면서, 위에 상황처럼 긴민한 관계를 끊어 주기 위해 중간에 추상적인 연결고리가 필요하다. 추상적인 연결고리를 만들기에 자바에서 제공하는 가장 유용한 도구가 인터페이스 이다.public interface ConnectionMaker { Connection makeConnection() throws ClassNotFoundException, SQLException;} ConnectionMaker 라는 이름의 인터페이스를 정의한다. 이 인터페이스를 사용하는 UserDao 입장에서는 어떤 클래스로 만들었는지 상관없이 ConnectionMaker 타입의 오브젝트라면 makeConnection() 메서드를 호출하기만 하면 Connection 타입의 오브젝트를 반환해줄것으로 기대할 수 있다.public class DConnectionMaker implements ConnectionMaker { @Override public Connection makeConnection() throws ClassNotFoundException, SQLException { // D DB 커넥션 생성코드 ... }} ConnectionMaker 를 구현한 DConnectionMaker 클래스 필요에 맞게 D DB 커넥션을 생성하도록 메서드를 구현만 해주면 된다.public class UserDao { private ConnectionMaker connectionMaker; public UserDao() { this.connectionMaker = new DConnectionMaker(); } public void add(User user) throws ClassNotFoundException, SQLException { Connection c = connectionMaker.makeConnection(); ... } public User get(String id) throws ClassNotFoundException, SQLException { Connection c = connectionMaker.makeConnection(); ... }} ConnectionMaker 를 받아서 그 안에 있는 makeConnection() 메서드를 사용하기 때문에 UserDao 의 입장에서는 어떤 클래스로 ConnectionMaker 가 구현되었는지 알 필요가 없다. 그러나 여기서 문제점이 하나 발생하는데, 초기에 생성자를 통해 DConnectionMaker 오브젝트를 사용하도록 결정하는 코드가 여전히 UserDao 에 남아 있다. 결국 다른 ConnectionMaker 로 변경을 하려할때 이 부분에서 UserDao 의 코드에 수정이 일어나게 된다.관계설정 책임 분리 UserDao 에서 생성자를 통해 DConnectionMaker 오브젝트를 사용하도록 결정하는 코드가 남아 있는 문제를 해결하기 위해 관계설정 책임을 분리시켜 보자. 현재로는 UserDao 의 생성자에서 관계를 설정하고 있어 그 책임이 UserDao 에 있다. 이 책임을 UserDao 가 아닌 UserDao 를 사용하는 쪽에 둔다면 어떻게 될까? public class UserDao { private ConnectionMaker connectionMaker; public UserDao(ConnectionMaker connectionMaker) { this.connectionMaker = connectionMaker; } public void add(User user) throws ClassNotFoundException, SQLException { Connection c = connectionMaker.makeConnection(); ... } public User get(String id) throws ClassNotFoundException, SQLException { Connection c = connectionMaker.makeConnection(); ... }} 책임을 분리하기 위해 기존에 생성자에서 사용할 오브젝트를 결정하는 것이 아니라 매개변수를 통해 사용할 오브젝트가 결정 되도록 변경하였다.public static void main(String[] args) throws ClassNotFoundException, SQLException { ConnectionMaker connectionMaker = new DConnectionMaker(); UserDao userDao = new UserDao(connectionMaker); ...} UserDao 를 사용하는 main 메서드에서 이제 어떤 ConnectionMaker 를 사용할 것인지 설정을 하고 그걸 인자값으로 넘겨 UserDao 와 ConnectionMaker 간의 관계를 설정해준다. 이렇게 되면 UserDao 의 경우 어떤 클래스로 ConnectionMaker 를 구현하였는지 알 필요가 없게 된다. 이게 바로 다형성이 가지는 큰 힘이다. 앞으로 ConnectionMaker 를 구현하는 클래스가 변경되더라도 UserDao 의 코드는 전혀 수정할 필요없이, UserDao 를 사용하는 쪽에서 변경된 클래스와 관계를 설정해주기만 하면 된다. 다른 DAO 클래스에서도 ConnectionMaker 를 구현한 클래스를 그대로 가져다 사용이 가능하기 때문에 상속에 비해 확장에 있어 매우 유연하게 변경되었다.REFERENCE토비의 스프링 3.1 Vol. 1 스프링의 이해와 원리" }, { "title": "(Test)외부 API 테스트", "url": "/posts/(Test)%EC%99%B8%EB%B6%80-API-%ED%85%8C%EC%8A%A4%ED%8A%B8/", "categories": "Test", "tags": "Test", "date": "2022-11-04 13:00:00 +0900", "snippet": "외부 API 테스트문제 상황 GitHub OAuth 를 통해 회원이 로그인을 진행하는 로직을 단위 테스트 진행하던 중 문제가 발생했다. 로그인을 하게 되면, 우선 요청을 통해 해당 유저의 Token 값을 받아오고 그 Token 을 활용하여 User 의 정보를 가져와 JWT 을 생성하여 해당 웹앱에 로그인을 할 수 있는 JWT 와 User 의 정보를...", "content": "외부 API 테스트문제 상황 GitHub OAuth 를 통해 회원이 로그인을 진행하는 로직을 단위 테스트 진행하던 중 문제가 발생했다. 로그인을 하게 되면, 우선 요청을 통해 해당 유저의 Token 값을 받아오고 그 Token 을 활용하여 User 의 정보를 가져와 JWT 을 생성하여 해당 웹앱에 로그인을 할 수 있는 JWT 와 User 의 정보를 반환해주는 방식으로 로그인이 진행되고 있다. 서비스 로직에 WebClient 를 통해 외부 API 요청으로 User 의 정보와 User 의 정보를 요청할 수 있는 Token 을 가져오는 로직이 있었는데, 여기서 Test 코드에서 임의로 설정한 Url 로 API 요청을 하는 경우 잘못된 Url 요청이라는 에러가 발생하고 있다.문제 원인 테스트를 진행할때 실제 API 를 사용하지 못하므로, 임의의 Url 로 API 요청 시 존재하지 않는 Url 을 통한 API 요청으로 에러가 발생에러 문구문제 코드Token 을 요청하는 코드@Service@RequiredArgsConstructorpublic class OAuthService { private ResponseOauthTokenDto requestToken(String code, OauthProvider provider) { return webClient.post() .uri(provider.getTokenUrl()) .accept(MediaType.APPLICATION_JSON) .bodyValue(tokenRequest(code, provider)) .retrieve() .bodyToMono(ResponseOauthTokenDto.class) .block(); }} User 의 정보를 요청할 수 있는 Token 을 받아오는 코드이다. 여기서 API Url 를 통해 데이터를 요청하여 값을 받고 있는데, 테스트를 진행할때는 실제 API 요청을 보내지 않다 보니 문제가 발생하고 있다.User 정보를 요청 하는 코드@Service@RequiredArgsConstructorpublic class OAuthService { private ResponseUserDto getUserProfile( OauthProvider provider, ResponseOauthTokenDto tokenResponse ) { return webClient.get() .uri(provider.getUserInfoUrl()) .header(\"Authorization\", \"token \" + tokenResponse.getAccessToken()) .retrieve() .bodyToMono(ResponseUserDto.class) .block(); }} 외부 API 를 통해 UserProfile 데이터를 가져오는 코드이다. 위와 동일한 문제가 발생하고 있다.테스트 코드@DisplayName(\"비즈니스 로직 - OAuth\")@ExtendWith(MockitoExtension.class)class OAuthServiceTest { @InjectMocks private OauthService sut; @Mock private MemberRepository memberRepository; private ObjectMapper mapper = new ObjectMapper(); @DisplayName(\"유저가 OAuth 회원가입 요청을 하면, 유저 정보를 반환해 준다.\") @Test void 유저_회원가입_성공() throws Exception { //given String code = \"code\"; OauthProvider oauthProvider = createOAuthProvider(); ResponseOauthTokenDto responseOauthTokenDto = createResponseOAuthTokenDto(); ResponseUserDto responseUserDto = createRequestUserDto(); given(inMemoryProviderRepository.getProvider()).willReturn(oauthProvider); given(memberRepository.save(member)).willReturn(member); //when ResponseLoginDto loginDto = sut.signup(code); //then SoftAssertions.assertSoftly(softly -&gt; { softly.assertThat(loginDto.getAccessToken()) .as(\"외부 API 요청을 통해 생성된 accessToken 과 로그인 결과 반환되는 accessToken 은 동일해야 한다.\") .isEqualTo(responseOauthTokenDto.getAccessToken()); softly.assertThat(loginDto.getName()) .as(\"외부 API 요청을 통해 받아온 username 과 반환되는 username 은 동일해야 한다.\") .isEqualTo(responseUserDto.getName()); }); then(memberRepository).should().save(member); }} 처음 작성한 테스트 위에 코드로 테스트를 진행하면, WebClient 를 통해 API 에 요청을 진행할때 임의로 만들 OAuthProvider() 에 설정해둔 Url 로 요청을 하게되는데 이 경우 당연하게도 없는 Url 로 요청을 하는것이기 때문에 에러가 발생하게 된다.문제 해결 방법 임의의 테스트용 MockWebServer 를 사용해서, 그쪽으로 API 요청을 하고 임의의 MockWebServer 에 우리가 원하는 Response 가 반환되도록 설정하여 해결하는 방법 WebClient 를 Mocking 하여 사용 해결하는 방법MockWebServer 사용 우선 여러 설정도 필요하고 처음 사용하면 조금은 복잡하고 어렵지만, Spring Team 또한 이 방법을 사용하여 Test 를 진행한다고 하며 권장하는 방법이라고 한다.implementation 'com.squareup.okhttp3:okhttp:4.10.0'testImplementation 'com.squareup.okhttp3:mockwebserver:4.10.0' 우선 MockWebServer 을 사용하기 위해 build.gradle 에 의존성을 추가해줘야 한다. https://mvnrepository.com 사이트에서 okhttp 와 mockwebserver 를 검색해서 추가하면 된다.https://square.github.io/okhttp/ 공식 사이트 문서도 읽어 보면 좋을것 같다. 여담으로 라이브러리 자체가 kotlin 으로 되어있어, 내부 코드를 보고 싶었는데 이해하기 어려웠다.@DisplayName(\"비즈니스 로직 - OAuth\")@ExtendWith(MockitoExtension.class)class OAuthServiceTest { private static MockWebServer mockBackEnd; @InjectMocks private OauthService sut; ... @BeforeAll static void setUp() throws IOException { mockBackEnd = new MockWebServer(); mockBackEnd.start(); } @AfterAll static void tearDown() throws IOException { mockBackEnd.shutdown(); } void init() { String baseUrl = String.format(\"http://localhost:%s\", mockBackEnd.getPort()); sut = OauthService.byTest(inMemoryProviderRepository, memberRepository, jwtTokenProvider, redisTemplate, baseUrl); }} 테스트 코드에서도 추가적인 설정이 필요하다. setUp(): 모든 테스트가 실행되기전 MockWebServer 를 생성하고, Server 를 Start 해줘야한다. tearDown(): 모든 테스트가 종료되면 MockWebServer 를 종료해줘야 한다. init(): 테스트가 실행되기전 WebClient 에 BaseUrl 을 설정해주기 위해 테스트 전용 생성자를 통해 OAuthService 를 생성 하여 sut 에 넣어준다. @DisplayName(\"유저가 OAuth 회원가입 요청을 하면, 유저 정보를 반환해 준다.\")@Testvoid 유저_회원가입_성공() throws Exception { ... //Object Mapper 를 사용해 responseDto 를 변환 String responseOAuthTokenDtoToString = mapper.writeValueAsString(responseOauthTokenDto); String responseUserDtoToString = mapper.writeValueAsString(responseUserDto); //Token API Response 설정 mockBackEnd.enqueue( new MockResponse() .setBody(responseOAuthTokenDtoToString) .addHeader(\"Content-Type\", MediaType.APPLICATION_JSON) ); // User Info API Response 설정 mockBackEnd.enqueue( new MockResponse() .setBody(responseUserDtoToString) .addHeader(\"Content-Type\", MediaType.APPLICATION_JSON) ); ...} 테스트 메서드 내부에 WebClient 를 통해 API 요청 시 반환해줄 Response 를 enqueue() 메서드를 사용해 설정해준다. APPLICATION_JSON 타입으로 각각 responseOAuthTokenDtoToString 와 responseUserDtoToString 이 body 에 실려 반환 된다. @DisplayName(\"비즈니스 로직 - OAuth\")@ExtendWith(MockitoExtension.class)class OAuthServiceTest { @InjectMocks private OauthService sut; @Mock private MemberRepository memberRepository; private ObjectMapper mapper = new ObjectMapper(); ... @DisplayName(\"유저가 OAuth 회원가입 요청을 하면, 유저 정보를 반환해 준다.\") @Test void 유저_회원가입_성공() throws Exception { //given init(); String code = \"code\"; OauthProvider oauthProvider = createOAuthProvider(); ResponseOauthTokenDto responseOauthTokenDto = createResponseOAuthTokenDto(); ResponseUserDto responseUserDto = createRequestUserDto(); String responseOAuthTokenDtoToString = mapper.writeValueAsString(responseOauthTokenDto); String responseUserDtoToString = mapper.writeValueAsString(responseUserDto); Member member = responseUserDto.toMemberByTest(); mockBackEnd.enqueue( new MockResponse().setBody(responseOAuthTokenDtoToString) .addHeader(\"Content-Type\", MediaType.APPLICATION_JSON) ); mockBackEnd.enqueue( new MockResponse().setBody(responseUserDtoToString) .addHeader(\"Content-Type\", MediaType.APPLICATION_JSON) ); given(inMemoryProviderRepository.getProvider()).willReturn(oauthProvider); given(memberRepository.save(member)).willReturn(member); //when ResponseLoginDto loginDto = sut.signup(code); //then SoftAssertions.assertSoftly(softly -&gt; { softly.assertThat(loginDto.getAccessToken()) .as(\"외부 API 요청을 통해 생성된 accessToken 과 로그인 결과 반환되는 accessToken 은 동일해야 한다.\") .isEqualTo(responseOauthTokenDto.getAccessToken()); softly.assertThat(loginDto.getName()) .as(\"외부 API 요청을 통해 받아온 username 과 반환되는 username 은 동일해야 한다.\") .isEqualTo(responseUserDto.getName()); }); then(memberRepository).should().save(member); }} 완성된 테스트 코드 우리가 설정해둔 임의의 Response 가 잘 반환되는걸 확인할 수 있다. [2d74c81b] HTTP POST http://localhost:49416/tokenUrl[2d74c81b] [25a822f1-1, L:/127.0.0.1:49417 - R:localhost/127.0.0.1:49416] Response 200 OK[5b8572df] HTTP GET http://localhost:49416/userInfoUrl[5b8572df] [25a822f1-2, L:/127.0.0.1:49417 - R:localhost/127.0.0.1:49416] Response 200 OK 추가적으로 테스트 실행 후 로그를 살펴보면 위에 처럼 우리가 설정해준 Url 로 요청을 보내고 200 OK 를 반환받는걸 확인 할 수 있다.WebClient Mocking 사용 우선 이방법은 권장되지 않는 방법이다. 여러 이유가 있는데 우선 WebClient 를 구현하고 있는 DefaultWebClient 에서 WebClient 동작에 사용되는 모든 메서드를 Mocking 해줘야한다. 서비스에서 WebClient 가 어떻게 사용되는지 세부 구현 내용을 전부 알아야 하기 때문에 좋지 못한 테스트 방법이 된다. when(webClientMock.get()) .thenReturn(requestHeadersUriSpecMock); when(requestHeadersUriMock.uri(oauthProvider.getTokenURl)) .thenReturn(requestHeadersSpecMock); when(requestHeadersMock.retrieve()) .thenReturn(responseSpecMock); when(responseMock.bodyToMono(ResponseOauthTokenDto.class)) .thenReturn(responseOauthTokenDto); 이정도의 Mocking 이 필요하며, MockWebServer 를 사용하는 방식에 비해 간단하다 생각 할 수 있지만 테스트가 여러개의 경우 매번 이런 Mocking 은 매우 번거로울수 있다. 테스트 케이스가 몇개 없고, 추가적인 외부 라이브러리를 사용이 어려울때 사용하면 좋을것 같다.정리사용 테스트 케이스가 매우 적거나, 외부 라이브러리를 사용하지 못하는 특별한 경우에는 WebClient 를 Mocking 하여 사용하는것이 좋을것 같다. 그 외 경우에는 초기 설정이 조금은 복잡하지만 MockWebServer 를 사용할것 같다.느낀점 항상 외부 API 를 사용하는 로직을 테스트할때 많은 어려움이 있는데, 또 다른 방법을 배운것 같아 좋았다.REFERENCE Mocking a WebClient in Spring OkHttp" }, { "title": "(JPA)엔티티 업데이트 시 발생한 문제(Dirty Checking, @PreUpdate)", "url": "/posts/(JPA)%EC%97%94%ED%8B%B0%ED%8B%B0-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8-%EC%8B%9C-%EB%B0%9C%EC%83%9D%ED%95%9C-%EB%AC%B8%EC%A0%9C(Dirty-Checking,-@PreUpdate)/", "categories": "JPA", "tags": "JPA", "date": "2022-10-31 18:18:00 +0900", "snippet": "엔티티 업데이트 시 발생한 문제(Dirty Checking, @PreUpdate) 제목을 딱 짧고 명확하게 하기 어려워 주저리 주저리 썼다.문제 상황 글을 작성하고, 수정할 수 있는 간단한 프로젝트를 하던 와중에 글(Post) 을 수정할때 수정 시간을 @PreUpdate 를 통해 값을 넣어주고 있었는데 여기서 문제가 발생하였다. 엔티티를 수정하고...", "content": "엔티티 업데이트 시 발생한 문제(Dirty Checking, @PreUpdate) 제목을 딱 짧고 명확하게 하기 어려워 주저리 주저리 썼다.문제 상황 글을 작성하고, 수정할 수 있는 간단한 프로젝트를 하던 와중에 글(Post) 을 수정할때 수정 시간을 @PreUpdate 를 통해 값을 넣어주고 있었는데 여기서 문제가 발생하였다. 엔티티를 수정하고, 수정된 엔티티를 반환받아 Json 으로 뿌려주고 있었는데 분명 DB 에는 수정 시간이 잘 등록되고 있는데 반환받은 값 에는 수정 시간 값 이 제대로 등록되어 있지 않은 문제 발생 조금만 생각해 보면 왜 그런지 쉽게 풀 수 있는 문제 였으나, 그래도 이왕 이런 문제가 발생하였으니 영속성 관리 와 엔티티 수정 시 주의할 점을 함께 작성해 보면 좋을것 같아 글을 쓰게 되었다.Update queryupdate \"post\" set body=?, deleted_at=?, registered_at=?, title=?, updated_at=?, user_id=? where id=? Dirty Checking 을 통해 Update query 가 발생하고 있다.DB 상태 DB 값을 보면 분명 업데이트가 정상적으로 이뤄지고, 업데이트 시간 또한 값을 잘 들어와 있는걸 볼 수 있다.Json 반환{ \"resultCode\": \"SUCCESS\", \"result\": { \"id\": 2, \"title\": \"updated title\", \"body\": \"updated body\", \"user\": { \"id\": 1, \"username\": \"test1\", \"role\": \"USER\", \"registeredAt\": \"2022-10-30T15:53:31.049+00:00\", \"updatedAt\": null, \"deletedAt\": null }, \"registeredAt\": \"2022-10-31T07:44:21.642+00:00\", \"updatedAt\": null, \"deletedAt\": null }} 위에 DB 값처럼 title 과 body 의 값은 잘 변경되어 뿌려지는걸 볼 수 있으나, updatedAt 의 값은 null 로 반환되고 있는걸 볼 수 있다.문제 코드PostService@Servicepublic class PostService { ... @Transactional public Post modify(Long postId, String title, String body, String username) { ... PostEntity modifyPostEntity = postEntity.updatePost(title, body); return Post.from(modifyPostEntity); }} 글(Post) 을 수정하는 로직이 있는 PostService class 에 modify() 메서드 코드이다. 수정값을 매개변수로 받아서, PostEntity 의 updatePost() 메서드로 인자값을 보내 PostEntity 내부에서 값을 변경하는 로직이다. 내부의 값이 변경되면서, 트랙젝션이 종료될때 Dirty Checking 을 통해 DB 에 업데이트가 이뤄지고 있다.PostEntity@Entitypublic class PostEntity { ... private Timestamp updatedAt; @PreUpdate void updatedAt() { this.updatedAt = Timestamp.from(Instant.now()); } public PostEntity updatePost(String title, String body) { this.title = title; this.body = body; return this; } ...} PostEntity 내부의 updatePost() 메서드 매개변수로 title 과 body 값을 받아서, 값을 변경 하고 자기자신을 return 해주고 있다.PostController@RestController@RequestMapping(\"/api/v1/posts\")@RequiredArgsConstructorpublic class PostController { ... @PutMapping(\"/{postId}\") public Response&lt;PostResponse&gt; modify( @RequestBody PostModifyRequest request, @PathVariable Long postId ) { Post modifyPost = postService.modify(postId, request.getTitle(), request.getBody()); return Response.success(PostResponse.from(modifyPost)); }} 업데이트에 필요한 PostService 내부의 modify() 를 호출해주고 있으며, modify() 메서드에서 반환된 값을 PostResponse 로 변환하여 클라이언트 쪽으로 보내주고 있다.문제 원인첫번째 원인 @PreUpdate 는 과연 언제 updatedAt 에 값을 넣어주고 있는가?@Entitypublic class PostEntity { ... private Timestamp updatedAt; @PreUpdate void updatedAt() { this.updatedAt = Timestamp.from(Instant.now()); } public PostEntity updatePost(String title, String body) { this.title = title; this.body = body; return this; } ...} PostEntity 에서 사용중인 @PreUpdate 는 현재 상황에서는 트랙젝션 커밋 되기전, flush() 가 발생한 이후 Dirty Checking 이 일어나 Update Query 가 발생하며 그 순간 UpdatedAt 에 값이 들어가게 된다.두번째 원인 영속성 관리에서 flush() 는 언제 발생하는가?@Servicepublic class PostService { ... @Transactional public Post modify(Long postId, String title, String body, String username) { ... PostEntity modifyPostEntity = postEntity.updatePost(title, body); return Post.from(modifyPostEntity); }} @Transactional 어노테이션을 달려 있는 메서드의 활동이 종료되는 순간 트랜젝션 커밋 이 발생하게 되면 커밋하기 전 에 엔티티 매니저 내부에서 flush() 가 먼저 호출된다.세번째 원인 업데이트 직후 그 값을 받아 바로 뿌려주는건 좋게 설계 되어 있는 동작인가?@RestController@RequestMapping(\"/api/v1/posts\")@RequiredArgsConstructorpublic class PostController { ... @PutMapping(\"/{postId}\") public Response&lt;PostResponse&gt; modify( @RequestBody PostModifyRequest request, @PathVariable Long postId ) { Post modifyPost = postService.modify(postId, request.getTitle(), request.getBody()); return Response.success(PostResponse.from(modifyPost)); }} 위 처럼 값을 수정하고, 바로 반환된 값을 클라이언트에 보내준다면 아무래도 조회를 다시 하는 번거로움을 사라질것 같긴 하지만 \"조회와 로직은 따로 분리하는게 더 좋은 설계다.\" 라고 영한님께서 말씀하신적이 있어 좀 더 고민해 봐야하는 문제인것 같다.문제 해결첫번째 방법 조회와 업데이트 로직을 분리 한다.@Servicepublic class PostService { ... @Transactional public void modify(Long postId, String title, String body, String username) { ... PostEntity modifyPostEntity = postEntity.updatePost(title, body); }} @RestController @RequestMapping(\"/api/v1/posts\") @RequiredArgsConstructor public class PostController { ... @PutMapping(\"/{postId}\") public Response&lt;Void&gt; modify( @RequestBody PostModifyRequest request, @PathVariable Long postId ) { Post modifyPost = postService.modify(postId, request.getTitle(), request.getBody()); return Response.success(); }} PostService 와 PostController 에서 업데이트 이후의 값을 반환받아 클라이언트로 보내는 것이 아니라 업데이트는 업데이트만 진행을 하고 조회는 따로 조회만을 진행하는 방향으로 설계를 바꾸는 것이다.두번째 방법 EntityManager 를 통해 flush() 를 발생시켜준다.@Service@RequiredArgsConstructorpublic class PostService { ... @PersistenceContext private final EntityManager entityManager; @Transactional public Post modify(Long postId, String title, String body, String username) { ... PostEntity modifyPostEntity = postEntity.updatePost(title, body); entityManager.flush(); return Post.from(modifyPostEntity); }} 직접 EntityManager 를 주입 받아서 updatePost() 메서드가 종료되는 시점 이후 flush() 해주게 되면 현재 변경되어 있는 값이 즉시 적용되어 updatedAt 의 값도 의도한대로 잘 들어가게 된다. DB 상태 또한 잘 변경되는걸 볼 수 있다.{ \"resultCode\": \"SUCCESS\", \"result\": { \"id\": 2, \"title\": \"updated title!\", \"body\": \"updated body!\", \"user\": { \"id\": 1, \"username\": \"test1\", \"role\": \"USER\", \"registeredAt\": \"2022-10-30T15:53:31.049+00:00\", \"updatedAt\": null, \"deletedAt\": null }, \"registeredAt\": \"2022-10-31T07:44:21.642+00:00\", \"updatedAt\": \"2022-10-31T08:42:20.460+00:00\", \"deletedAt\": null }} Json 반환 또한 updatedAt 의 값이 잘 들어가 있는걸 볼 수 있다. 08:42 + 9 를 하게되면 한국 시간으로 되어 17시 42분 에 update 된걸 알 수 있다.세번째 방법 JPA 에서 제공해주고 있는 save() 대신 saveAndFlush() 를 사용한다. Dirty Checking 을 통해 업데이트를 진행하는 것이 아니라 postEntityRepository 에서 saveAndFlush() 를 사용해서 update 와 동시에 flush() 를 시켜주면 된다. @Service@RequiredArgsConstructorpublic class PostService { ... private final PostEntityRepository postEntityRepository; @Transactional public Post modify(Long postId, String title, String body, String username) { ... PostEntity modifyPostEntity = postEntityRepository.saveAndFlush( postEntity.updatePost(title, body) ); return Post.from(modifyPostEntity); }} postEntityRepository.saveAndFlush() 를 사용하게 되면 save 와 동시에 flush() 가 발생하여, 변경사항을 즉시 적용하게 된다.@Repository@Transactional(readOnly = true)public class SimpleJpaRepository&lt;T, ID&gt; implements JpaRepositoryImplementation&lt;T, ID&gt; { ... @Transactional @Override public &lt;S extends T&gt; S saveAndFlush(S entity) { S result = save(entity); flush(); return result; } @Transactional @Override public &lt;S extends T&gt; S save(S entity) { Assert.notNull(entity, \"Entity must not be null.\"); if (entityInformation.isNew(entity)) { em.persist(entity); return entity; } else { return em.merge(entity); } } @Transactional @Override public void flush() { em.flush(); } ...} save() 메서드의 경우 isNew 즉 새로운 entity 가 아니면 merge 를 새로운 entity 이면 persist 해주고 있는걸 볼 수 있다. 즉 이 방법은 변경감지에 의한 업데이트 가 아니라 병합을 통한 업데이트 가 이뤄지고 있는걸 알 수 있다. saveAndFlush() 의 메서드 경우 확인해 보면 두번째 방법에서 처럼 EntityManager 를 통해 flush() 를 해주고 있는걸 볼 수 있다. DB 상태 또한 잘 변경되는걸 볼 수 있다.{ \"resultCode\": \"SUCCESS\", \"result\": { \"id\": 2, \"title\": \"updated title!!!!\", \"body\": \"updated body!!!!\", \"user\": { \"id\": 1, \"username\": \"test1\", \"role\": \"USER\", \"registeredAt\": \"2022-10-30T15:53:31.049+00:00\", \"updatedAt\": null, \"deletedAt\": null }, \"registeredAt\": \"2022-10-31T07:44:21.642+00:00\", \"updatedAt\": \"2022-10-31T08:52:00.616+00:00\", \"deletedAt\": null }} Json 반환 또한 updatedAt 의 값이 잘 들어가 있는걸 볼 수 있다. 08:52 + 9 를 하게되면 한국 시간으로 되어 17시 52분 에 update 된걸 알 수 있다. 정리앞으로 앞으로는 설계를 분리해서 이런 문제가 발생할 여지조차 주지 않는 방향으로 작업을 진행할 것 같지만, 그게 안되는 상황에서는 두번째 방법을 사용하지 않을까 싶다. 아무래도 병합을 통한 업데이트는 영한님께서도 주의를 해야한다고 강의에서 말씀하신 적이 있는것 같아서 사용하는데 있어 조심스러울것 같다.느낌점 알고있다고 생각하는게 가장 무서운 거라고, 분명 코드를 작성할때는 문제가 없을것이라 생각했지만 아니였다. 좀 만 생각해보면 풀 수 있는 문제 였지만 그래도 처음부터 문제가 없는게 제일 좋은것이니 앞으로는 Entity 의 업데이트 로직을 작성할때는 좀 더 주의를 해야할 것 같다.REFERENCE자바 ORM 표준 JPA 프로그래밍 - 기본편" }, { "title": "(TEST)테스트 중 @Value Null 문제", "url": "/posts/(Test)%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%A4%91-@Value-Null-%EB%AC%B8%EC%A0%9C/", "categories": "TEST", "tags": "TEST", "date": "2022-10-27 15:06:00 +0900", "snippet": "테스트 중 @Value Null 문제문제 상황 JWT 를 활용하는 프로젝트를 진행하는 도중에 외부에 노출되어서는 안되는 값을 local.yml 파일에 등록하여 관리하고 있었는데단위 테스트를 진행하면서, @Value 를 통해 local.yml 파일에 명시 해둔 값을 가져오는 과정에서 값을 가져오지 못하고 null 값으로 처리되는 문제가 발생 디버깅 ...", "content": "테스트 중 @Value Null 문제문제 상황 JWT 를 활용하는 프로젝트를 진행하는 도중에 외부에 노출되어서는 안되는 값을 local.yml 파일에 등록하여 관리하고 있었는데단위 테스트를 진행하면서, @Value 를 통해 local.yml 파일에 명시 해둔 값을 가져오는 과정에서 값을 가져오지 못하고 null 값으로 처리되는 문제가 발생 디버깅 창에서 보이듯이 값이 null 로 설정되어 있다.문제 코드local.ymljwt: secret-key: secrty-key-example # 30 days expired-tine-ms: 2592000000 JWT 를 생성할때 필요하면서, 외부에 노출되어서는 안되는 값을 local.yml 파일에 등록하여 관리하는 중, 배포할때는 환경변수를 사용해야 하기 때문에 ${JWT_SECRET_KEY} 와 ${JWT_EXPORED_TIME_MS} 로 바꿔 배포할 예정이다.UserService.java@Service@RequiredArgsConstructor@Transactional(readOnly = true)public class UserService { private final UserEntityRepository userEntityRepository; private final BCryptPasswordEncoder passwordEncoder; @Value(\"${jwt.secret-key}\") private String secretKey; @Value(\"${jwt.expired-tine-ms}\") private Long expiredTimeMs; public String login(String username, String password) { UserEntity userEntity = userEntityRepository.findByUsername(username).orElseThrow( () -&gt; new SnsApplicationException(ErrorCode.USER_NOT_FOUND, String.format(\"%s not founded\", username)) ); if (!isPasswordValid(password, userEntity)) { throw new SnsApplicationException(ErrorCode.INVALID_PASSWORD); } return JwtTokenUtils.generateToken(username, secretKey, expiredTimeMs); } private boolean isPasswordValid(String password, UserEntity userEntity) { return passwordEncoder.matches(password, userEntity.getPassword()); }} 문제의 @Value 를 사용하는 Service 코드 유저가 로그인을 시도하고, 로그인에 성공하였을 경우 JWT 토큰을 생성하여 Controller 로 반환해주는 로직이 있다. 여기서 JwtTokenUtils 사용해서 JWT 토큰을 생성하여 반환해 주고 있는데, 이곳에서 local.yml 에 등록되어 있는 값이 필요하다.UserServiceTest.java@ExtendWith(MockitoExtension.class)class UserServiceTest { @InjectMocks private UserService userService; @Mock private UserEntityRepository userEntityRepository; @Mock private BCryptPasswordEncoder passwordEncoder; @Test void loginSuccessTest() { String username = \"username\"; String password = \"password\"; UserEntity userEntity = UserEntityFixture.get(username, password); given(userEntityRepository.findByUsername(username)).willReturn(Optional.of(userEntity)); given(passwordEncoder.matches(password, userEntity.getPassword())).willReturn(true); Assertions.assertThatCode(() -&gt; userService.login(username, password)) .doesNotThrowAnyException(); then(userEntityRepository).should().findByUsername(username); then(passwordEncoder).should().matches(password, userEntity.getPassword()); }} UserService 로직 중에 login 성공 상황을 테스트하는 코드 다른것은 mocking 을 통해 해결이 되었는데, login() 메서드 마지막에 JWT 를 반환해주는 곳에서 문제가 발생했다. 위에 말하였듯이 @SpringBootTest 어노테이션을 사용하지 않고, Unit 테스트를 진행하고 있었는데 여기서 @Value 의 값을 넣어줘야 하는데 Spring 없이 테스트를 하고 있어서 값을 넣어주지 못하고 있었다. 코드를 실행하면 NPE 가 발생하는 상황💧문제 해결 방법 @SpringBootTest 어노테이션을 사용한다.(가장 빠르고 쉬운 해결 방법) ReflectionTestUtils 를 사용해여 필드값을 셋팅해준다.(Reflection.. 최후의 수단) @Value 를 필드가 아닌 생성자의 매개변수에 선언하고, 테스트에서 Service 를 생성해서 사용하는 방법@SpringBootTestspring: profiles: default: test application.yml 에 default profiles 를 test 로 지정jwt: secret-key: test-secret-key # 30 days expired-tine-ms: 25223 application-test.yml 에 테스트 용도로 사용할 값을 설정@SpringBootTestclass UserServiceTest { @Autowird private UserService userService; ...} @SpringBootTest 어노테이션을 사용하고, UserService 를 @Autowird 해준다. 이 방법은 매우 쉽지만, Unit 테스트를 하고자 했던 테스트 방식을 통합 테스트 방식으로 변경해야 하는 치명적인 단점이 있다. ReflectionTestUtiles@ExtendWith(MockitoExtension.class)class UserServiceTest { @InjectMocks private UserService userService; @Mock private UserEntityRepository userEntityRepository; @Mock private BCryptPasswordEncoder passwordEncoder; @BeforeEach public void setUp() { ReflectionTestUtils.setField(userService, \"secretKey\", \"test-secret-key\"); ReflectionTestUtils.setField(userService, \"expiredTimeMs\", 25223L); }} 다른 별도의 설정 없이 Unit 테스트를 하고 있던 코드에 @BeforeEach 를 사용하여 Test 를 setUp 해주는 메서드에 ReflectionTestUtils.setField()` 를 활용해, 필드 값을 강제로 설정해주는 방식을 사용 할 수 있다. Unit 테스트를 유지하면서, 정말 간단하게 @Value 를 사용하던 필드에 값을 넣어 줄 수 있다. Reflection 을 사용하긴 하지만, 그래도 Test 용도로만 사용하는 것이니 크게 문제될것 없을것이라 생각했다. Reflection 을 통한 set 방식을 무분별하게 사용하면 변경에 너무 열려있는 코드가 되는것 같아 혹시 또 다른 방법은 없을지 찾아 보기로 했다. 14:32:23.988 [main] DEBUG org.springframework.test.util.ReflectionTestUtils - Setting field 'secretKey' of type [null] on target object [com.bong.sns.service.UserService@3003697] or target class [class com.bong.sns.service.UserService] to value [test-secret-key]14:32:23.990 [main] DEBUG org.springframework.test.util.ReflectionTestUtils - Setting field 'expiredTimeMs' of type [null] on target object [com.bong.sns.service.UserService@3003697] or target class [class com.bong.sns.service.UserService] to value [25223] 추가적으로 Reflection 방식을 사용하면 Spring 콘솔에 해당 로그가 찍힌다. null 값으로 설정되던 필드들이 ReflectionTestUtils 통해 set 해준 값으로 설정된걸 확인할 수 있다.테스트에서 Service 를 생성하여 사용@Service@Transactional(readOnly = true)public class UserService { private final UserEntityRepository userEntityRepository; private final BCryptPasswordEncoder passwordEncoder; private String secretKey; private Long expiredTimeMs; public UserService(UserEntityRepository userEntityRepository, BCryptPasswordEncoder passwordEncoder, @Value(\"${jwt.secret-key}\") String secretKey, @Value(\"${jwt.expired-tine-ms}\") Long expiredTimeMs) { this.userEntityRepository = userEntityRepository; this.passwordEncoder = passwordEncoder; this.secretKey = secretKey; this.expiredTimeMs = expiredTimeMs; } public String login(String username, String password) { UserEntity userEntity = userEntityRepository.findByUsername(username).orElseThrow( () -&gt; new SnsApplicationException(ErrorCode.USER_NOT_FOUND, String.format(\"%s not founded\", username)) ); if (!isPasswordValid(password, userEntity)) { throw new SnsApplicationException(ErrorCode.INVALID_PASSWORD); } return JwtTokenUtils.generateToken(username, secretKey, expiredTimeMs); }} Service 에서 @Value 의 값을 가져오도록 필드값에 지정하는 것이 아니라, 생성자의 매개변수에 지정@ExtendWith(MockitoExtension.class)class UserServiceTest { @InjectMocks private UserService userService; @Test void loginSuccessTest() { String username = \"username\"; String password = \"password\"; // test 용 Jwt 설정 값 String secretKey = \"test-secret-key\"; Long expiredTimeMs = 25223L; UserEntity userEntity = UserEntityFixture.get(username, password); // 새로운 UserService 를 생성하면서, 생성에 필요한 인자 값을 넣어준다. UserService newUserService = new UserService(userEntityRepository, passwordEncoder, secretKey, expiredTimeMs); given(userEntityRepository.findByUsername(username)).willReturn(Optional.of(userEntity)); given(passwordEncoder.matches(password, userEntity.getPassword())).willReturn(true); Assertions.assertThatCode(() -&gt; newUserService.login(username, password)) .doesNotThrowAnyException(); then(userEntityRepository).should().findByUsername(username); then(passwordEncoder).should().matches(password, userEntity.getPassword()); }} 테스트 용도로 사용할 UserService 를 생성하고, 생성할때 JWT 설정 값과 필요한 값을 인자 값으로 넣어준다. 생성된 UserService 를 테스트에서 사용하기 때문에 @Value 를 통해 값을 가져오지 않더라도, 해당 필드값에는 null 이 아닌 우리가 넘겨준 값이 설정되게 된다. 코드에 변경이 위에 방법에 비해 다소 많지만, 생성자를 통한 주입으로 field 주입과 setter 주입이 좋지 않아 사용하면 안된다는 문제도 함께 해결이 가능하다. (@Value 를 필드에 선언하는 것도 하나의 필드 주입이라 생각한다.) Unit 테스트도 유지 할 수 있고, Reflection 을 사용하지도 않으며, Debug 로그가 찍히지도 않는다. 앞으로 @Value 가 있는 경우 테스트를 진행해야 한다면 위에 방식을 사용하지 않을까 싶다. 당연하지만, 값이 잘 설정되어 있는걸 확인할 수 있다.그 외 구글에 검색해보면 위에 명시한 방법 외에도 다양한 해결방법이 있는것 같다. 상황에 따라 위에 상황을 활용하지 못하게 된다면 또 다른 방법을 적용해 보면 좋을것 같다.@Value 사용하면서 조금 불편했던 것이 key 의 값이 변경될 경우 @Value 를 사용한 모든 곳을 일일이 찾아서 key 값을 변경해 줘야 하는 불편함이 있었다. 찾아보니 @Value 를 사용하는것이 좋지 못한 방법이라는 이야기도 있다. 우선 이 글에서는 @Value 를 사용한 상태에서 테스트 작성을 위주로 하기 때문에 다음에 @Value 를 대체할 방법에 대해 포스팅 해봐야겠다." }, { "title": "(Project)Enum Converter", "url": "/posts/(Project)Enum-Converter/", "categories": "Project", "tags": "Project", "date": "2022-10-19 01:19:00 +0900", "snippet": "Enum Converter현재 상황 Controller 와 Request 를 담당하는 DTO 에서 Enum 타입 을 사용하고 싶은데, 소문자로 데이터가 들어올 경우 아래 문구의 예외가 발생하는 문제가 있다.IllegalArgumentException: No enum constant team20.issuetracker.domain.issue.I...", "content": "Enum Converter현재 상황 Controller 와 Request 를 담당하는 DTO 에서 Enum 타입 을 사용하고 싶은데, 소문자로 데이터가 들어올 경우 아래 문구의 예외가 발생하는 문제가 있다.IllegalArgumentException: No enum constant team20.issuetracker.domain.issue.IssueStatus.open] 왜 굳이 Enum 을 사용해야 하는가?? 웹 애플리케이션에서 데이터의 값을 사전에 정의된 값으로 제한을 하고 싶어서, Enum을 사용 우리가 제한한 데이터 외의 값이 들어올 경우 예외 처리를 편리하게 할 수 있는 장점이 있다. public enum IssueStatus { OPEN, CLOSED;} IssueStatus 의 경우 OPEN 이라는 값이 있지만 소문자로 들어온 open 과는 다른 값으로 취급 되고 있다.문제 상황첫번째 문제 상황@GetMapping(params = \"is\")public ResponseEntity&lt;ResponseReadAllIssueDto&gt; readOpenAndClosedIssues( @RequestParam(value = \"page\", required = false, defaultValue = \"1\") String page, @RequestParam(\"is\") IssueStatus status) { ...} Controller 에서 Enum 으로 @RequestParam 데이터를 바인딩을 하려는 상황에서 Query String 으로 전달된 데이터가 소문자일 경우 바인딩 에러가 발생하고 있다.두 번째 문제 상황@Getter@NoArgsConstructor(access = AccessLevel.PRIVATE)@AllArgsConstructor(access = AccessLevel.PRIVATE)public class RequestUpdateMilestoneDto { @NotEmpty @Size(max = 50, message = \"Milestone 의 제목은 20글자를 넘을 수 없습니다.\") private String title; @Size(max = 800, message = \"Milestone 의 본문은 800글자를 넘을 수 없습니다.\") private String description; @FutureOrPresent(message = \"과거의 시간을 설정할 수는 없습니다.\") @JsonFormat(pattern = \"yyyy-MM-dd\") private LocalDate dueDate; private MilestoneStatus milestoneStatus; public static RequestUpdateMilestoneDto of(String title, String description, LocalDate dueDate, MilestoneStatus milestoneStatus) { return new RequestUpdateMilestoneDto(title, description, dueDate, milestoneStatus); }} 첫번째 상황과 비슷한 상황으로 이번에는 Milestone 을 Update 할때 현재 또는 변경되는 상태의 값을 받아야 하는데 이 값 또한 Enum 타입 으로 받고 있는 상황에서 데이터가 소문자로 들어 올 경우 바인딩 에러가 발생하고 있다.문제 이유private static class StringToEnum&lt;T extends Enum&gt; implements Converter&lt;String, T&gt; {\tprivate final Class&lt;T&gt; enumType;\tStringToEnum(Class&lt;T&gt; enumType) {\t\tthis.enumType = enumType;\t}\t@Override\t@Nullable\tpublic T convert(String source) {\t\tif (source.isEmpty()) {\t\t\t// It's an empty enum identifier: reset the enum value to null.\t\t\treturn null;\t\t}\t\treturn (T) Enum.valueOf(this.enumType, source.trim());\t}} 스프링에서 기본적으로 제공해주는 StringToEnum 컨버터의 경우 위에 코드에 나와 있듯이 source 를 공백만 제거한 다음 별 다른 처리 없이 valueOf 를 해주고 있어 소문자로 들어오면 그대로 소문자로, 대문자로 들어오면 대문자로 바인딩을 해주기 때문에 문제가 발생하고 있다.해결 시도첫번째 시도 프론트쪽에서 소문자가 아닌 대문자로 데이터를 보내줄수 없는지 요청을 드렸었다 하지만, 여러 작업을 이미 소문자로 진행하였기 때문에 변경이 쉽지는 않다고 이야기를 하셔서 백엔드쪽에서 해결하도록 결정하였다.두번째 시도@GetMapping(params = \"is\")public ResponseEntity&lt;ResponseReadAllIssueDto&gt; readOpenAndClosedIssues( @RequestParam(value = \"page\", required = false, defaultValue = \"1\") String page, @RequestParam(\"is\") String status) { ... ResponseReadAllIssueDto findOpenAndCloseIssues = issueService.findAllOpenAndCloseIssues (pageRequest, IssueStatus.valueOf(status.toUpperCase());} 위에 문제가 되는 값을 String 으로 받은 후 String.toUpperCase() 를 사용해서 대문자로 변경한 뒤 Enum 에 적용 시키는 방법을 시도 위에 방법으로 해결이 가능하기는 했으나, Enum 을 사용하고자 했던 취지에는 벗어나기 때문에 다른 방법이 없나 다시 한번 찾아보기 시작했다.세번째 시도 스프링 기본 Converter 를 사용하는 것이 아니라 Custom Converter 를 만들어서 사용public class StringToIssueStats implements Converter&lt;String, IssueStatus&gt; { @Override public IssueStatus convert(String status) { try { return IssueStatus.valueOf(status.toUpperCase()); } catch (IllegalArgumentException e) { return null; } }} Converter 인터페이스를 구현하는 클래스 StringToIssueStatus 를 만들어서 convert 메서드를 Override 해서 내가 원하는 방식으로 변경하면 된다. 기존에는 별다른 처리 없이 Enum.valueOf 를 통해 데이터를 변환했다면, 지금은 status 라는 값이 들어올 경우 toUpperCase() 메서드를 사용해 대문자로 변경을 한 뒤 데이터를 변환하는 방식으로 진행되게끔 만들었다. @Configurationpublic class WebConfig implements WebMvcConfigurer { @Override public void addFormatters(FormatterRegistry registry) { registry.addConverter(new StringToIssueStats()); }} 위에 클래스를 만든다고 해서 그냥 사용이 되는것은 아니고 Bean 으로 등록을 하거나 Config 설정 클래스에서 Converter 로 추가해주면 기존 Converter 가 아닌 내가 구현한 Converter 를 사용하게 된다. Milestone Update 또한 같은 방식으로 Converter 를 구현해서 사용하여 쉽게 해결 됐다. REFERENCE Using Enums as Request Parameters in Spring" }, { "title": "(Project)페이징 처리 시 발생한 문제", "url": "/posts/(Project)%ED%8E%98%EC%9D%B4%EC%A7%95-%EC%B2%98%EB%A6%AC-%EC%8B%9C-%EB%B0%9C%EC%83%9D%ED%95%9C-%EB%AC%B8%EC%A0%9C/", "categories": "Project", "tags": "Project", "date": "2022-10-14 15:30:00 +0900", "snippet": "페이징 처리 시 발생한 문제문제 상항 현재 Issue및 Page 상태- Issue Entity는 Member와 Milestone Entity에 대해 @ManyToOne 관계를 맺고 있다.-\tMilestone 의 경우 Issue에 등록 되어 있을 수도 있고 없을 수도 있다.- Issue 를 OPEN, COLSE 상태 별로 전체 조회하는 로직이 ...", "content": "페이징 처리 시 발생한 문제문제 상항 현재 Issue및 Page 상태- Issue Entity는 Member와 Milestone Entity에 대해 @ManyToOne 관계를 맺고 있다.-\tMilestone 의 경우 Issue에 등록 되어 있을 수도 있고 없을 수도 있다.- Issue 를 OPEN, COLSE 상태 별로 전체 조회하는 로직이 필요하다.- 첫 시작 Page 는 1로 해야하고, Size는 25이다. Issue-tracker 프로젝트를 진행하면서 Issue 조회에 대해 페이징 처리를 하던 중 문제가 두 가지 발생하였다. 첫번째 문제로는 Issue에 Milestone 이 없는 경우 전체 조회를 진행하여도 리스트에 나타나지 않는 문제가 있었다. 두번째 문제로는 query specified join fetching, but the owner of the fetched association was not present in the select list 라는 문구의 예외가 발생하였다.문제 코드@Query(value = \"select i from Issue i join fetch i.member m join fetch i.milestone mi where i.status = :status\")Page&lt;Issue&gt; findIssues(Pageable pageable, @Param(\"status\") IssueStatus status); 위 코드가 OPEN, CLOSE 상태 별 Issue 를 전체 조회 하는 코드이다. 딱 봤을때 문제가 없는 코드라고 생각하였는데, 두 가지 문제가 발생하여 많이 당황했다.첫번째 문제 상태별 Issue를 조회 할 때 해당 Issue에 Milestone 이 등록되어 있지 않은 경우 Issue를 조회 해도 리스트에 나타나지 않는 문제가 있다.문제 원인 그냥 join fetch 를 했을때 어떤 join 이 발생하는지 알고 있다면 쉽게 해결할 수 있는 문제다. 그냥 join fetch 를 하면 inner join이 발생하게 되는데 inner join의 경우 join 대상이 null 일 경우 데이터를 가져오지 않기 때문에 Issue를 조회할때 Milestone이 없을 경우 리스트에 나타나지 않는것이였다.해결 방법 left join fetch 를 하게되면 left join 이 발생하기 때문에 join 대상인 Milestone 에 값이 없어도 Issue를 가져오기 때문에 이 방법으로 해결 할 수 있었다.해결 코드@Query(value = \"select i from Issue i left join fetch i.member m left join fetch i.milestone mi where i.status = :status\")Page&lt;Issue&gt; findIssues(Pageable pageable, @Param(\"status\") IssueStatus status);두번째 문제 이번에는 query specified join fetching, but the owner of the fetched association was not present in the select list라는 문구의 예외가 발생하면서 실행조차 되지 않았다. 우선 N+1 문제를 해결하기 위해 @ManyToOne 관계를 가진 Entity를 join fetch 시켜주었다. 그리고 Issue의 상태별 조회를 위해 where 문을 사용하였다. @ManyToOne 관계에 join fetch 를 하는것은 데이터의 뻥튀기가 없기 때문에 이부분은 문제가 아니라 생각했다. join fetch 시 where문을 사용하는것은 join 대상에 where 문을 사용하는 것이 아니라면 문제가 없기 때문에 이부분도 문제가 아닐것이라 생각했다.해결 방법 해결 방법이 도저히 생각이 안나 검색을 하기 시작했다. 다행히 stackoverflow 나와 같은 문제를 겪고 있는 사람의 글을 보게되었다. 해결 방법으로는 count query를 따로 작성해 주면 된다는 것이였다. 이부분에서 오잉? 하고 의문이 들었다. 알고 있기로는 페이징 처리를 하면 임의로 count query를 생성해서 날려주는 것으로 알고 있었기 때문이다. 검색을 통해 문제를 해결하긴 했지만, 여전히 왜 이런 문제가 발생하는지 너무 궁금하여 인프런을 통해 영한님께 질문을 드렸다.문제 원인 인프런에 달려있던 영한님의 답변으로 왜 이런 문제가 발생하는지 알 수 있었다. JPA가 임의로 날려주는 쿼리의 경우 JPA가 많이 똑똑하지 못해 조회 결과가 바뀌어 버리기 때문에 정상적인 count의 값을 가져올 수 없어 발생 하는 문제라고 하셨다. fetch join 이나 where 문을 함께 사용하는 복잡한 쿼리의 경우 count query를 꼭 분리해서 사용해야한다는 답을 얻었다.해결 코드@Query(value = \"select i from Issue i left join fetch i.member m left join fetch i.milestone mi where i.status = :status\", countQuery = \"select count(i) from Issue i left join i.member left join i.milestone where i.status = :status\")Page&lt;Issue&gt; findIssues(Pageable pageable, @Param(\"status\") IssueStatus status);REFERENCE 영한님 답변 stackoverflow 답변" }, { "title": "(Project)API 최적화", "url": "/posts/(Project)API-%EC%B5%9C%EC%A0%81%ED%99%94/", "categories": "Project", "tags": "Project", "date": "2022-10-09 23:30:00 +0900", "snippet": "API 최적화(N+1)모든 Issue 조회 API 모든 Issue 조회 시 하나의 Issue마다 8개의 SELECT QUERY가 발생 하나의 Issue에 Milestone, Label, Comment, Assignee가 각 1개 있는 기준 각기 다른 Label, Milestone, Comment, Assignee가 있을 경우...", "content": "API 최적화(N+1)모든 Issue 조회 API 모든 Issue 조회 시 하나의 Issue마다 8개의 SELECT QUERY가 발생 하나의 Issue에 Milestone, Label, Comment, Assignee가 각 1개 있는 기준 각기 다른 Label, Milestone, Comment, Assignee가 있을 경우 더 많은 Query가 발생될 것으로 예상 Issue의 개수에 따라 지연로딩으로 인한 여러번의 반복 쿼리가 발생 1차 캐쉬에 데이터가 없는 기준으로 8개의 쿼리가 발생하고 있는데, 위의 경우 처럼 각기 다른 종류의 Label 등을 하나씩만 가지고 있는 Issue가 100개 라면 801개의 조회 쿼리가 발생하게 된다. 문제 발생문제 발생 구간 모든 Issue를 조회하고, DTO로 반환하는 곳에서 지연로딩으로 프록시로 되어있던 데이터들이 엔티티 데이터로 변환되는 과정에서 문제 발생private List&lt;ResponseIssueDto&gt; responseIssueDtos(List&lt;Issue&gt; findIssues) { return findIssues.stream() .map(ResponseIssueDto::of) .collect(Collectors.toList());} 스트림을 활용해 조회해온 Issue를 DTO로 변환하는 메서드 이부분에서 Issue의 개수 많큼 DTO를 로 변환하는 of 메서드를 호출 public static ResponseIssueDto of(Issue issue) { List&lt;ResponseMilestoneDto&gt; milestones = new ArrayList&lt;&gt;(); if (issue.getMilestone() != null) { milestones = List.of(ResponseMilestoneDto.from(issue.getMilestone())); } return new ResponseIssueDto( issue.getId(), issue.getTitle(), issue.getMember().getName(), issue.getMember().getProfileImageUrl(), issue.getComments().size(), issue.getContent(), issue.getCreatedAt(), issue.getStatus().toString().toLowerCase(), milestones, issue.getComments().stream() .map(ResponseCommentDto::from) .collect(Collectors.toList()), issue.getIssueLabels().stream() .map(IssueLabel::getLabel) .map(ResponseLabelDto::from) .collect(Collectors.toList()), issue.getIssueAssignees().stream() .map(IssueAssignee::getAssignee) .map(ResponseAssigneeDto::from) .collect(Collectors.toList()));} DTO를 생성 하는 메서드 위 메서드에서 지연로딩으로 인해 프록시 객체로 되어있는 객체를 엔티티 객체로 변환된다. 프록시 객체로 되어있는 객체를 엔티티 객체로 변환하는 과정에서 SELECT QUERY가 발생해결 방법 N + 1 의 대표적인 해결 방법인 FETCH JOIN 과 BATCH_FETCH_SIZE 를 설정하여 해결 모든 Issue 조회 시 모든 연관관계 엔티티에 FETCH JOIN을 사용하고 DISTINCT로 중복된 데이터를 제거하는 방법으로 N+1 문제를 해결 할 수도 있으나, 이 경우 OneToMany 관계의 엔티티도 FETCH JOIN을 하게 되어 페이징 관련 SQL이 발생하지 않고, 메모리에서 페이징 처리를 진행하게 되면서 Memory out bound exception 예외가 발생 할 수 있어 해당 방법을 사용하지 않았다. OneToMany에서 JOIN을 할 경우 Many의 수 많큼 데이터가 늘어나면서 DB 자체에서 페이징을 할수가 없게된다. Hibernate 경고 로그 발생 추가적으로 OneToMany 컬렉션 FETCH JOIN은 1개만 사용할 수 있다. 여러개를 사용할 경우 데이터가 부정확하게 조회될 수 있다. FETCH JOIN Issue 엔티티에서 XToOne 관계를 가지고 있는 엔티티에 대해 FETCH JOIN을 사용해서 지연로딩을 강제 초기화 시킨다. XToOne 관계는 JOIN으로 인한 데이터의 증가가 없기 때문에 FETCH JOIN을 사용 @Query(\"select i from Issue i join fetch i.member m join fetch i.milestone mi\")List&lt;Issue&gt; findAllIssue(); XToOne 관계를 가지는 member, milestone 엔티티에 fetch join 사용BATCH_FETCH_SIZE XToMany 관계의 엔티티에 대해 페이징 문제와 프록시 문제를 해결하기 위해 사용 BATCH_FETCH_SIZE 를 설정하면 IN Query 를 사용해서 Issue 관련된 Label, Comment, Assignee 를 각각 하나의 쿼리로 SIZE 만큼의 데이터를 가져온다. SIZE 만큼의 데이터를 미리 다 가져오기 때문에 지연로딩으로 인해 발생되는 SELECT QUERY를 줄일 수 있다. select label0_.id as id1_5_0_, label0_.author_id as author_i2_5_0_, label0_.created_at as created_3_5_0_, label0_.updated_at as updated_4_5_0_, label0_.background_color as backgrou5_5_0_, label0_.description as descript6_5_0_, label0_.text_color as text_col7_5_0_, label0_.title as title8_5_0_ from label label0_ where label0_.id=? BATCH_FETCH_SIZE 설정 하기 전 쿼리 Label 데이터를 각각 하나씩 가져오게 된다. Label 의 개수 만큼 SELET QUERY 발생 select label0_.id as id1_5_0_, label0_.author_id as author_i2_5_0_, label0_.created_at as created_3_5_0_, label0_.updated_at as updated_4_5_0_, label0_.background_color as backgrou5_5_0_, label0_.description as descript6_5_0_, label0_.text_color as text_col7_5_0_, label0_.title as title8_5_0_ from label label0_ where label0_.id in ( ?, ? ) BATCH_FETCH_SIZE 설정 하기 후 쿼리 Label 데이터가 IN QUERY로 설정한 SIZE 만큼의 데이터를 한번에 가져온다.성능 개선발생 QUERY 개수 Issue 하나 당 8개의 QUERY가 발생하던 상황에서 여러개의 Issue가 있어도 6개의 QUERY 만으로 조회가 가능하도록 변경되었다.조회 속도- Issue: 500개- Lebel: 7개- Milestone: 2개- Comment: 100개 랜덤 더미 데이터 개수 개선 전: 모든 이슈 조회 시 약 1500개의 SELETE QUERY가 발생하면서, 많은 데이터의 양이 아님에도 조회에 10초 이상의 시간 소요 개선 후: BATCH_FETCH_SIZE 500 기준 단 6개의 SELETE QUERY로 조회 완료, 시간 또한 조회 버튼을 클릭하자마자 바로 결과가 나타나도록 개선되었다." }, { "title": "(JPA)기본값 타입", "url": "/posts/(JPA)%EA%B8%B0%EB%B3%B8%EA%B0%92-%ED%83%80%EC%9E%85/", "categories": "JPA", "tags": "JPA", "date": "2022-10-03 23:27:00 +0900", "snippet": "기본값 타입JPA의 데이터 타입 분류엔티티 타입 @Entity로 정의하는 객체 데이터가 변해도 식별자로 지속해서 추적이 가능하다. 회원이나, 팀 엔티티의 필드 값이 변경되더라도 식별자로 인식이 가능하다. 값 타입 int, Integer, String 처럼 단순히 값으로 사용하는 자바 기본 타입이나 객체 식별자 없이 값만...", "content": "기본값 타입JPA의 데이터 타입 분류엔티티 타입 @Entity로 정의하는 객체 데이터가 변해도 식별자로 지속해서 추적이 가능하다. 회원이나, 팀 엔티티의 필드 값이 변경되더라도 식별자로 인식이 가능하다. 값 타입 int, Integer, String 처럼 단순히 값으로 사용하는 자바 기본 타입이나 객체 식별자 없이 값만 있어 변경 시에 추적이 불가능하다.값 타입 분류기본값 타입 자바 기본 타입(int, double) 래퍼 클래스(Integer, Long) String 생명 주기를 엔티티에 의존한다. 회원을 삭제하면 이름, 나이 필드도 삭제 된다. 값 타입은 공유하면 안된다. 회원 이름 변경 시 다른 회원의 이름도 함께 변경되면 안된다. Integer같은 래퍼 클래스나 String 같은 특수한 클래스는 공유가 가능한 객체지만, 변경은 불가능하다.REFERENCE 자바 ORM 표준 JPA 프로그래밍 - 기본편#JPA_기본값_타입" }, { "title": "(JPA)값 타입과 불변객체", "url": "/posts/(JPA)%EA%B0%92-%ED%83%80%EC%9E%85%EA%B3%BC-%EB%B6%88%EB%B3%80%EA%B0%9D%EC%B2%B4/", "categories": "JPA", "tags": "JPA", "date": "2022-10-02 21:27:00 +0900", "snippet": "값 타입과 불변객체값 타입 공유 참조 임베디드 타입 같은 값 타입을 여러 엔티티에서 공유하면 위험하다. side effect 가 발생 할 가능성이 높아진다. 값 타입 복사 값 타입의 실제 인스턴스인 값을 공유하는것은 위험하다. 인스턴스 값을 복사해서 사용하는 것이 안전하다.객체 타입의 한계 항상 값을 복사해서 사용하면 ...", "content": "값 타입과 불변객체값 타입 공유 참조 임베디드 타입 같은 값 타입을 여러 엔티티에서 공유하면 위험하다. side effect 가 발생 할 가능성이 높아진다. 값 타입 복사 값 타입의 실제 인스턴스인 값을 공유하는것은 위험하다. 인스턴스 값을 복사해서 사용하는 것이 안전하다.객체 타입의 한계 항상 값을 복사해서 사용하면 공유 참조로 인해 발생하는 부작용을 피할 수 있다. 문제는 임베디드 타입처럼 직접 정의한 값 타입은 자바의 기본 타입이 아니라 객체 타입이다. 자바 기본 타입에 값을 대입하면 값을 복사하게 된다. 객체 타입은 참조 값을 직접 대입하는 것을 막을 방법이 없다. 객체의 공유 참조를 피할 수 없다.기본 타입int a = 10;int b = a;b = 4; b는 a의 값을 복사한것으로 b의 값을 변경하더라도 a의 값이 변경되지 않는다.객체 타입Address a = new Address(\"old\");Address b = a;b.setCity(\"new\"); b는 a의 값을 복사한것이 아니라 참조를 하고 있기 때문에 b에 변경이 일어나면 a도 함께 변경이 일어나게 된다.불변 객체 객체 타입을 수정할 수 없게 만들면 부작용을 차단할 수 있다. 값 타입은 불변 객체(immutable object)로 설계해야 한다. 생성자로만 값을 설정하고 수정자(setter)를 만들지 않으면 된다. 참고로 Integer, String은 자바가 제공하는 대표적인 불변객체이다.값 타입 비교 equals(), hashcode() 를 재정의 해서 비교할때 사용해야 한다. equals() 메서드를 재정의 할때는 주로 모든 필드를 사용한다.REFERENCE 자바 ORM 표준 JPA 프로그래밍 - 기본편#JPA_값 타입과 불변객체" }, { "title": "(JPA)JPQL 프로젝션", "url": "/posts/(JPA)JPQL-%ED%94%84%EB%A1%9C%EC%A0%9D%EC%85%98/", "categories": "JPA", "tags": "JPA", "date": "2022-09-29 21:19:00 +0900", "snippet": "JPQL 프로젝션프로젝션 SELECT 절에 조회할 대상을 지정하는 것 DESTINCT 로 중복 제거 가능하다. 대상: Entity, EmbeddedType, ScalaType SELECT m FROM Member m // Entity 프로젝션SELECT m.team FROM Member m // Entity 프로젝션SELECT m.addre...", "content": "JPQL 프로젝션프로젝션 SELECT 절에 조회할 대상을 지정하는 것 DESTINCT 로 중복 제거 가능하다. 대상: Entity, EmbeddedType, ScalaType SELECT m FROM Member m // Entity 프로젝션SELECT m.team FROM Member m // Entity 프로젝션SELECT m.address FROM Member m // Embedded 프로젝션SELECT m.username, m.age FROM Member m // Scala 프로젝션 엔티티 프로젝션Member member = new Member();member.setUsername(\"member1\");member.setAge(10);em.persist(member);em.flush();em.clear();List&lt;Member&gt; result = em.createQuery(\"select m from Member as m\", Member.class) .getResultList();Member findMember = result.get(0);findMember.setAge(20); 엔티티 프로젝션을 통해 SELECT 해온 결과들은 영속성 관리가 될까? 관리가 된다면 findMember.setAge(20) 을 통해 Update Query 가 발생해야 한다. 사실 처음에는 안될거라 생각했는데, 영속성 관리가 되고있다. 엔티티 프로젝션을 통해 SELECT 해온 결과는 모두 영속성 관리가 된다.// 나쁜 예List&lt;Team&gt; result = em.createQuery(\"select m.team from Member as m\", Team.class).getResultList();// 좋은 예List&lt;Team&gt; result = em.createQuery(\"select t from Member as m join m.team as t\", Team.class) .getResultList(); Member 의 Team 을 SELECT 한 결과도 영속성 관리가 된다. 단, 이 경우는 Join Query 가 발생한다.(묵시적 조인) 간단하게 JPQL 을 작성했는데, Join Query 가 발생되니 좋은것 같지만 JPQL 의 경우는 왠만하면 SQL과 비슷하게 작성하는것이 좋다. 나쁜 예 와 좋은 예 둘 다 결과 및 발생하는 쿼리는 같지만, Join 의 경우 성능적인 측면에서 차지하는 영향이 크기 때문에 나중에 성능 개선을 위해서라도 한눈에 보이도록 작성하는것이 좋다.(명시적 조인)임베디드 타입 프로젝션List&lt;Address&gt; result = em.createQuery(\"select o.address from Order as o\", Address.class) .getResultList(); Order 안에 있는 Embedded Type 의 Address 를 조회 할 수 있다. 소속되어있는 엔티티를 정해서 명시해줘야 하는 한계가 존재한다.여러값 조회 타입이 다른 여러 필드가 나열되어 있을때, 조회하는 방법 Query 타입으로 조회List resultList = em.createQuery(\"select m.username, m.age from Member m\").getResultList();Object o = resultList.get(0);Object[] result = (Object[]) o;System.out.println(\"username = \" + result[0]);System.out.println(\"age = \" + result[1]); Query 타입으로 조회 반환 타입이 명확하지 않아, Query 타입으로 조회 Query 타입으로 조회 시 Object로 반환되기 때문에 Object[] 로 타입 캐스팅이 필요하다. Type Query 로 조회List&lt;Object[]&gt; resultList = em.createQuery(\"select m.username, m.age from Member m\", Object[].class).getResultList(); Object[] result = resultList.get(0);System.out.println(\"username = \" + result[0]);System.out.println(\"age = \" + result[1]); TypeQuery 로 조회 Query 타입으로 조회할때 해줘야하는 타입 캐스팅 과정을 생략할 수 있다. new 명령어로 조회List&lt;MemberDto&gt; resultList = em.createQuery( \"select new com.sutdy.hellojpql.entity.Dto.MemberDto(m.username, m.age) from Member m\",MemberDto.class) .getResultList();MemberDto memberDto = resultList.get(0);System.out.println(\"username = \" + memberDto.getUsername());System.out.println(\"age = \" + memberDto.getAge()); 단순 값을 DTO로 바로 조회 할 수 있다. 패키지 명을 포함한 전체 클래스 명을 입력해줘야 한다. 패키지 명이 길어지면 코드도 지저분해지는 단점이 있다.(QueryDSL을 사용하면 극복 가능) 순서와 타입이 일치하는 생성자가 필요하다.REFERENCE 자바 ORM 표준 JPA 프로그래밍 - 기본편#JPA_JPQL_프로젝션" }, { "title": "(JPA)JPQL 조인", "url": "/posts/(JPA)JPQL-%EC%A1%B0%EC%9D%B8/", "categories": "JPA", "tags": "JPA", "date": "2022-09-27 14:36:00 +0900", "snippet": "JPQL 조인조인 종류내부 조인 SELETE m FROM Member m [INNER] JOIN m.team tTeam team = new Team();team.setName(\"teamA\");em.persist(team);Member member = new Member();member.setUsername(\"member\");member.setAge(...", "content": "JPQL 조인조인 종류내부 조인 SELETE m FROM Member m [INNER] JOIN m.team tTeam team = new Team();team.setName(\"teamA\");em.persist(team);Member member = new Member();member.setUsername(\"member\");member.setAge(10);em.persist(member);em.flush();em.clear();String query = \"select m from Member m inner join m.team t\";List&lt;Member&gt; result = em.createQuery(query, Member.class) .getResultList(); inner 는 생략이 가능하다.Hibernate: /* select m from Member m inner join m.team t */ select member0_.id as id1_0_, member0_.age as age2_0_, member0_.team_id as team_id4_0_, member0_.username as username3_0_ from Member member0_ inner join Team team1_ on member0_.team_id=team1_.id 발생한 Query, inner join 이 잘 되는걸 확인할 수 있다.외부 조인 SELETE m FROM Member m LEFT [OUTER] JOIN m.team tTeam team = new Team();team.setName(\"teamA\");em.persist(team);Member member = new Member();member.setUsername(\"member\");member.setAge(10);em.persist(member);em.flush();em.clear();String query = \"select m from Member m left outer join m.team t\";List&lt;Member&gt; result = em.createQuery(query, Member.class) .getResultList(); outer 는 생략이 가능하다.Hibernate: /* select m from Member m left outer join m.team t */ select member0_.id as id1_0_, member0_.age as age2_0_, member0_.team_id as team_id4_0_, member0_.username as username3_0_ from Member member0_ left outer join Team team1_ on member0_.team_id=team1_.id 발생한 Query세타 조인 SELETE COUNT(m) FROM Member m, Team t WHERE m.username = t.nameTeam team = new Team();team.setName(\"teamA\");em.persist(team);Member member = new Member();member.setUsername(\"member\");member.setAge(10);em.persist(member);em.flush();em.clear();String query = \"select m from Member m, Team t where m.username = t.name\";List&lt;Member&gt; result = em.createQuery(query, Member.class) .getResultList(); 연관관계가 없는 데이터를 조인 카테시안 곱이 발생 Hibernate: /* select m from Member m, Team t where m.username = t.name */ select member0_.id as id1_0_, member0_.age as age2_0_, member0_.team_id as team_id4_0_, member0_.username as username3_0_ from Member member0_ cross join Team team1_ where member0_.username=team1_.name 발생한 Query, cross join 이 발생한다.ON 절 ON 절을 활용한 조인(JPA 2.1부터 지원)조인 대상 필터링 회원과 팀을 조인하면서, 팀 이름이 A 인 팀만 조인 JPQL: SELECTE m, t FROM Member m LEFT JOIN m.team t on t.name = 'A' SQL: SELECT m.*, t.* FROM Member m LEFT JOIN Team t ON m.TEAM_ID = t.id and t.name = 'A' 회원의 이름과 팀의 이름이 같은 대상 외부 조인(연관관계가 없는 엔티티 외부 조인) JPQL: SELECT m, t FROM Member m LEFT JOIN Team t on m.username = t.name SQL: SELECT m.*, t.* FROM Member m LEFT JOIN Team t ON m.username = t.name 서브 쿼리메인 쿼리와 연관이 없는 서브쿼리 나이가 평균보다 많은 회원 SELECT m FROM Member mWHERE m.age &gt; (select avg(m2.age) from Member m2) 메인 쿼리와 서브 쿼리가 연관이 없어 따로 동작하므로 성능적인 측면에서 더 좋다.메인 쿼리와 연관이 있는 서브쿼리 한 건이라도 주문한 고객 SELECT m FROM Member mWHERE (select count(o) from Order o where m = o.member) &gt; 0 메인 쿼리와 서브 쿼리가 연관이 있는 상태서브 쿼리 지원 함수 [NOT] EXISTS (subquery): 서브 쿼리에 결과가 존재하면 참 {ALL, ANY, SOME} (subquery) ALL: 모두 만족하면 참 ANY, SOME: 같은 의미, 조건을 하나라도 만족하면 참 [NOT] IN (subquery): 서브 쿼리의 결과 중 하나라도 같은 것이 있으면 참지원 함수 예제 팀 A 소속인 회원 SELECT m FROM Member mWHERE EXISTS (select t from m.team t where t.name = '팀A') 전체 상품 각각의 재고보다 주문량이 많은 주문들 SELECT o FROM `Order` oWHERE o.orderAmount &gt; ALL (select p.stockAmount from Product p) 어떤 팀이든 팀에 소속되 회원 SELECT m FROM Member mWHERE m.team = ANY (select t from Team t) JPA 서브 쿼리의 한계 JPA는 WHERE, HAVING 절에서만 서브 쿼리를 사용할 수 있다. Hibernate 에서는 SELECT 절도 지원 FROM 절의 서브 쿼리는 현재 JPQL 에서는 불가능하다. 조인으로 풀 수 있으면 풀어서 해결 할 수 있다. REFERENCE 자바 ORM 표준 JPA 프로그래밍 - 기본편 ​ #JPA_JPQL_조인" }, { "title": "(JPA)JPQL 기본문법", "url": "/posts/(JPA)JPQL-%EA%B8%B0%EB%B3%B8%EB%AC%B8%EB%B2%95/", "categories": "JPA", "tags": "JPA", "date": "2022-09-25 23:00:00 +0900", "snippet": "JPQL 기본문법JPQL(Java Persistence Query Language)? JPQL 은 Entity 2022객체 대상으로 쿼리 한다. JPQL 은 특정 데이터베이스 SQL 에 의존적이지 않다. JPQL 은 결국 SQL 로 변환되어 실행된다.JPQL 문법select_문 :: = select_절 from_절 [where_절...", "content": "JPQL 기본문법JPQL(Java Persistence Query Language)? JPQL 은 Entity 2022객체 대상으로 쿼리 한다. JPQL 은 특정 데이터베이스 SQL 에 의존적이지 않다. JPQL 은 결국 SQL 로 변환되어 실행된다.JPQL 문법select_문 :: = select_절 from_절 [where_절] [groupby_절] [having_절] [orderby_절] update_문 :: = update_절 [where_절]delete_문 :: = delete_절 [where_절]select m from Member as m where m.age &gt; 18 엔티티와 속성은 대소문자로 구분한다.(Member, age) JPQL 키워드는 대소문자를 구분하지 않는다. 엔티티의 이름을 사용, 테이블 이름을 사용하는 것이 아니다. 별칭은 필수(as는 생략 가능하다.)집합과 정렬select COUNT(m), // 회원 수 SUM(m), // 나이 합 AVG(m), // 평균 나이 MAX(m), // 최대 나이 MIN(m) // 최소 나이from Member m ANSI SQL 에서 지원하는 함수는 모두 사용 가능하다.TypeQuery, QueryTypeQuery&lt;Member&gt; query = em.createQuery( \"SELECT m FROM Member as m\", Member.class); TypeQuery: 반환 타입이 명확할 때 사용Query query = em.createQuery( \"SELECT m.username, m.age FROM Member as m\"); Query: 반환 타입이 명확하지 않을 때 사용 m.username, m.age 두 개의 속성을 반환하기 때문에 타입을 명시 할 수 없어 Query 를 사용해야 한다.결과 조회 API query.getResultList() : 결과가 하나 이상일 때 사용, 리스트로 반환 결과가 없으면, 빈 리스트를 반환하기 때문에 NPE 에 대한 걱정을 하지 않아도 된다. query.getSingleResult() : 결과가 정확히 하나 일때 사용, 단일 객체로 반환 결과가 없으면 javax.persistence.NoResultException 발생 결과가 둘 이상이면 javax.persistence.NonUniqueResultException 발생 파라미터 바인딩TypedQuery&lt;Member&gt; query = em.createQuery(\"select m from Member as m where m.username = :username\", Member.class);query.setParameter(\"username\", \"member1\"); 이름 기준으로 파라미터 바인딩TypedQuery&lt;Member&gt; query = em.createQuery(\"select m from Member as m where m.username = ?1\", Member.class);query.setParameter(1, \"member1\"); 위치 기준으로 파라미터 바인딩 왠만하면 이름 기준으로 사용하자, 위치는 변경될 가능성도 높고 직관적이지 못하다. REFERENCE 자바 ORM 표준 JPA 프로그래밍 - 기본편#JPA_JPQL_기본문법" }, { "title": "(JPA)JPA의 다양한 쿼리 사용 방법", "url": "/posts/(JPA)JPA%EC%9D%98-%EB%8B%A4%EC%96%91%ED%95%9C-%EC%BF%BC%EB%A6%AC-%EC%82%AC%EC%9A%A9-%EB%B0%A9%EB%B2%95/", "categories": "JPA", "tags": "JPA", "date": "2022-09-22 23:48:00 +0900", "snippet": "JPA의 다양한 쿼리 사용 방법JPQL JPA 를 사용하게 되면 Entity 객체를 중심으로 개발하게 되는데, 검색 쿼리를 어떻게 처리해야할까? 검색을 할 때도 테이블이 아닌 Entity 객체를 대상으로 검색해야 한다. 모든 DB 데이터를 객체로 변환해서 검색하는 것은 불가능에 가깝다. 애플리케이션이 필요한 데이터만...", "content": "JPA의 다양한 쿼리 사용 방법JPQL JPA 를 사용하게 되면 Entity 객체를 중심으로 개발하게 되는데, 검색 쿼리를 어떻게 처리해야할까? 검색을 할 때도 테이블이 아닌 Entity 객체를 대상으로 검색해야 한다. 모든 DB 데이터를 객체로 변환해서 검색하는 것은 불가능에 가깝다. 애플리케이션이 필요한 데이터만 DB 에서 불러오려면 결국 검색 조건이 포함된 SQL 이 필요하다. JPA 는 SQL 을 추상화한 JPQL 이라는 객체 지향 쿼리 언어를 제공한다. SQL과 문법이 유사하며, ANSI SQL 에서 지원하는 모든것을 사용할 수 있다. SELECT, FROM, WHERE, GROUP BY, HAVING, JOIN 등등 JPQL 은 Entity 객체를 대상으로 쿼리 SQL 은 DB 테이블을 대상으로 쿼리 JPQL 을 작성하면, SQL 로 변역되어 동작하게 된다.String jpql = \"select m from Member m where m.name like '%hello%'\";List&lt;Member&gt; result = em.createQuery(jpql, Member.class).getResultList(); JPQL 작성Hibernate: /* select m from Member m where m.name like '%hello%' */ member0_.member_id, member0_.city, member0_.street, member0_.zipcode, member0_.name, from Member member0_ where member0_.name like '%hello%' JPQL 이 번역되어 발생한 SQL 위에 주석 처리를 통해 작성된 JPQL 을 보여주고, 아래에 실제 발생된 SQL 을 보여준다. 테이블이 아닌 객체를 대상으로 검색하는 객체지향 쿼리이다. SQL 을 추상화해서, 특정 데이터베이스 SQL 에 의존적이지 않다.Criteria 동적 쿼리를 활용하기 어려운 JPQL 의 단점을 보완할때 사용. 동적 쿼리를 활용할때 뿐만 아니라 다른 여러 기능을 활용할 수 있게 해준다. CriteriaBuilder cb = em.getCriteriaBuilder();CriteriaQuery&lt;Member&gt; = cb.createQuery(Member.class);Root&lt;Member&gt; m = query.from(Member.class);CriteriaQuery&lt;Member&gt; cq = query.select(m).where(cb.equal(m.get(\"name\"), \"kim\"));List&lt;Member&gt; result = em.createQuery(cq).getResultList(); 단순 사용 예제CriteriaBuilder cb = em.getCriteriaBuilder();CriteriaQuery&lt;Member&gt; query = cb.createQuery(Member.class);Root&lt;Member&gt; m = query.from(Member.class);CriteriaQuery&lt;Member&gt; cq = query.select(m);String name = \"hello\";if (name != null) { cq = cq.where(cb.equal(m.get(name), \"kim\"));}List&lt;Member&gt; result = em.createQuery(cq).getResultList(); 동적 쿼리 작성 예제Criteria 정리 문자(String)가 아닌 자바 코드로 JPQL 을 작성 할 수 있다. JPQL 빌더 역할 JPA 공식 기능 JPQL 에 비해 단순하지만, SQL 보다 직관적이지 않아 유지 보수 측면에서 매우 좋지 않다.(실무에서 활용하기에는 무리가 있다.) Criteria 대신 QueryDSL 사용을 권장한다.QueryDSL JPQL 을 좀 더 쉽게 활용하기 위해 사용하는 오픈소스 라이브러리 JPQL 빌더 역할 사용하기 전에 추가적인 설정이 필요하지만, 사용하기에는 매우 편리하다. 컴파일 시점에 문법 오류를 찾을 수 있다. 단순하고 쉽다.(실무에서 활용하기 좋다.) JPAFactoryQuery query = new JPAQueryFactory(em);QMember m = QMember.member;List&lt;Member&gt; list = query .selectFrom(m) .where(m.age.gt(18)) .orderBy(m.name.desc()) .fetch(); 단순 사용 예제네이티브 SQL JPA 가 제공하는 SQL 을 직접 사용하는 기능 JPQL 로 해결할 수 없는 특정 데이터베이스에 의존적인 기능 오라클 DB 의 CONNECT BY 등 특정 DB 만 사용하는 SQL 힌트 em.createNativeQuery(\"select member_id, city, street, zipcode, username from Member\") .getResultList(); 단순 사용 예제Hibernate: /* dynamic native SQL query */ select member_id, city, street, zipcode, username from Member 작성한 NativeQuery 그대로 적용되는것을 볼 수 있다.JDBC 직접 사용 네이티브 SQL 을 사용하기 보다 JDBC 를 직접 사용하는게 좋다. JPA 를 사용하면서 JDBC 커넥션을 직접 사용하거나, 스프링 JdbcTemplate, 마이바티스 등을 함께 사용할 수 있다. 주의할 점은 영속성 컨텍스트를 적절한 시점에 강제로 flush 해줘야 한다. JPA 를 우회해서 SQL 을 실행하기 직전에 영속성 컨텍스트를 수동 flush 해줘야 한다. flush 가 동작하는 시기: commit 되기 직전 그리고 query 가 발생 했을때 Member member = new Member();member.setName(\"member1\");em.persist(member);// Select Query가 발생하여, 자동으로 flush를 해준다.List&lt;Member&gt; result = em.createNativeQuery(sql).getResultList(); for (Member m : result) { System.out.println(\"member = \" + m);} JPA 기술을 사용할때는 자동으로 flush 해줘서 문제가 없다.Member member = new Member();member.setName(\"member1\");em.persist(member);// em.flush(); 강제로 flush()// dbconn.executeQuery(\"select * from member\"); JDBC 는 JPA 와 관련이 없기 때문에, 자동이로 flush 를 해주지 않는다. SQL 이 실행되기 전에 강제로 flush 를 꼭 해줘야 한다. REFERENCE 자바 ORM 표준 JPA 프로그래밍 - 기본편#JPA_다양한_쿼리_사용_방법" }, { "title": "(JPA)영속성 전이와 고아객체", "url": "/posts/(JPA)%EC%98%81%EC%86%8D%EC%84%B1-%EC%A0%84%EC%9D%B4%EC%99%80-%EA%B3%A0%EC%95%84%EA%B0%9D%EC%B2%B4/", "categories": "JPA", "tags": "JPA", "date": "2022-09-21 23:48:00 +0900", "snippet": "영속성 전이와 고아객체영속성 전이(CASCADE) 특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속 상태로 만들고 싶을때 사용한다.엔티티 생성 일대다, 다대일 양방향 관계를 가지는 엔티티를 생성 @Entitypublic class Parent { @Id @GeneratedValue private Long id; pr...", "content": "영속성 전이와 고아객체영속성 전이(CASCADE) 특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속 상태로 만들고 싶을때 사용한다.엔티티 생성 일대다, 다대일 양방향 관계를 가지는 엔티티를 생성 @Entitypublic class Parent { @Id @GeneratedValue private Long id; private String name; @OneToMany(mappedBy = \"parent\") private List&lt;Child&gt; childList = new ArrayList&lt;&gt;(); // 양방향 편의 메서드 public void addChild(Child child) { childList.add(child); child.setParent(this); }} 부모 엔티티@Entitypublic class Child { @Id @GeneratedValue private Long id; private String name; @ManyToOne @JoinColumn(name = \"parent_id\") private Parent parent;} 자식 엔티티엔티티 저장Child child1 = new Child();Child child2 = new Child();Parent parent = new Parent();parent.addChild(child1);parent.addChild(child2);em.persist(parent);em.persist(child1);em.persist(child2); CASCADE가 없을때 엔티티와 연관된 엔티티 모두를 저장하기 위해서는 persist를 3번 호출해야 한다.(매우 불편)@OneToMany(mappedBy = \"parent\", cascaed = CascadeType.ALL)private List&lt;Child&gt; childList = new ArrayList&lt;&gt;(); CASCADE 설정을 해주면 한번의 em.persist(parent) 로 child 까지 함께 저장이 가능해진다.영속성 전이 주의 영속성 전이는 연관관계 매핑과는 아무련 관련이 없다. 엔티티를 영속화 할 때 연관된 엔티티도 함께 영속화 하는 편리함을 제공할 뿐이다. 하나의 부모가 자식을 관리할때(소유자가 하나일때) 사용하면 매우 의미가 있다. 라이프 사이클이 유사한 엔티티간에 사용하면 좋다. 만약 다른 엔티티에서 자식을 관리하거나, 연관관계가 있으면 사용하면 안된다.영속성 전이 종류 ALL: 모두 적용 PERSIST: 영속 REMOVE: 삭제 MERGE: 병합 REFERESH: REFERESH DETACH: DETACH고아 객체고아 객체 사용법 참조가 제거된 엔티티는 다론 곳에서 참조하지 않는 고아 객체로 보고 삭제하는 기능 고아 객체 제거: 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제하는 기능 orphanRemoval = true 를 설정 @OneToMany(mappedBy = \"parent\", cascaed = CascadeType.ALL, orphanRemoval = true)private List&lt;Child&gt; childList = new ArrayList&lt;&gt;();Parent parent = em.find(Parent.class, parent.getId());parent.getChildList().remove(0); // 자식 엔티티를 컬렉션에서 제거 위에 코드처럼 자식 엔티티를 컬렉션에서 제거하게 되면, 자동으로 child를 삭제 하는 쿼리가 발생하게 된다. DELETE FROM CHILD WHERE ID = ? 고아 객체 주의 참조하는 곳이 하나일 때 사용해야 한다. 특정 엔티티의 소유자가 하나일때 사용 @OneToOne, @OneToMany만영속성 전이 + 고아 객체 CascadeType.ALL + orphanRemoval = true 스스로 생명주기를 관리하는 엔티티는 em.persist()로 영속화, em.remove()로 제거 두 옵션을 모두 활성화 하면 부모 엔티티를 통해서 자식의 생명주기를 관리 할 수 있다. 도메인 주도 설계(DDD)의 Aggregate Root 개념을 구현할 때 유용하다. REFERENCE 자바 ORM 표준 JPA 프로그래밍 - 기본편#JPA_즉시로딩 #JPA_지연로딩" }, { "title": "(Algorithm)백준1541번_잃어버린 괄호", "url": "/posts/(Algorithm)%EB%B0%B1%EC%A4%80-1541%EB%B2%88-%EC%9E%83%EC%96%B4%EB%B2%84%EB%A6%B0-%EA%B4%84%ED%98%B8/", "categories": "Algorithm", "tags": "Algorithm", "date": "2022-09-20 23:04:00 +0900", "snippet": "[백준] 1541: 잃어버린 괄호(JAVA)문제 링크 1541번: 잃어버린 괄호예제1번 예제 입력: 55-50+40 출력: -35 55-(50+40) 과 같이 괄호를 쳐주면 예제에서 주어지는 식의 값을 최소로 만들 수 있다.2번 예제 입력: 10+20+30+40 출력: 100 - 연산자가 존재하지 않아, 있는 그대로 식을 계산하면 된다.풀...", "content": "[백준] 1541: 잃어버린 괄호(JAVA)문제 링크 1541번: 잃어버린 괄호예제1번 예제 입력: 55-50+40 출력: -35 55-(50+40) 과 같이 괄호를 쳐주면 예제에서 주어지는 식의 값을 최소로 만들 수 있다.2번 예제 입력: 10+20+30+40 출력: 100 - 연산자가 존재하지 않아, 있는 그대로 식을 계산하면 된다.풀이접근 방법 중요 키워드: 이 식의 값을 최소로 만들려고 한다. 값을 최소로 만들기 위해서는 어떻게 해야하는지만 생각할 수 있으면 쉽게 문제를 해결할 수 있다. 값을 최소로 만들기 위해서는 가장 큰 수를 빼주면 된다. 덧셈 부분을 먼저 계산한 후에 빼주면 끝.풀이 순서 뺄셈 연산자를 기준으로 문자열을 분리해준다. 분리된 문자열에 있는 수를 전부 더해준다.. 더해준 값을 뺄셈한다.코드입, 출력public class Bjo1541 { public static void main(String[] args) throws IOException { BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(System.out)); String equation = bufferedReader.readLine(); Bjo1541 bjo1541 = new Bjo1541(); int result = bjo1541.solution(equation); bufferedReader.close(); bufferedWriter.write(result + \"\\n\"); bufferedWriter.flush(); bufferedWriter.close(); }}로직public class Bjo1541 { public int solution(String equation) { int answer; // 문자열을 밸셈 연산자를 기준으로 분리 String[] token = equation.split(\"-\"); int[] sums = new int[token.length]; for (int i = 0; i &lt; token.length; i++) { int sum = 0; // 분리된 문자열에 있는 수를 전부 덧셈 for (int j = 0; j &lt; token[i].split(\"\\\\+\").length; j++) { sum += Integer.parseInt(token[i].split(\"\\\\+\")[j]); } sums[i] = sum; } // 첫번째 값이 음수가 되는 문제를 막기위해 첫번째 index 값을 answer로 설정 answer = sums[0]; // 덧셈한 값을 뺄셈 for (int i = 1; i &lt; sums.length; i++) { answer -= sums[i]; } return answer; }} + 연산자로 문자열을 분리할때 그냥 \"+\" 하면 regex.PatternSyntaxException 이 발생한다. + 문자를 이스케이프 처리해줘야 의도한 대로 문자열을 분리 할 수 있다. answer = sums[0] 에서 answer 를 sums 의 0번째 index 에 있는 값으로 두지 않고, for 반복문에서 sums 0번째 index 부터 모든 값을 뺄셈하는 경우 첫 번째가 음수가 되어 정상적으로 문제 해결이 되지 않는다. 이 문제에서 이 부분이 가능 큰 함정이라 생각했다. 문제에서 가장 처음과 마지막 문자는 숫자이다. == 첫번째 수는 무조건 양수이다. 예제 테스트class Bjo1541Test { static Stream&lt;Arguments&gt; example() { return Stream.of( Arguments.of(\"55-50+40\", -35), Arguments.of(\"10+20+30+40\", 100), Arguments.of(\"00009-00009\", 0) ); } @MethodSource(\"example\") @ParameterizedTest(name = \"[{index}] expected: {0} =&gt; actual: {1}\") void test(String input, int expected) { Bjo1541 bjo1541 = new Bjo1541(); int actual = bjo1541.solution(input); assertThat(actual).isEqualTo(expected); }} assertj 를 사용한 테스트 코드를 통해 주어진 예제에 대해 정상적으로 풀이가 되고 있는지 확인 예제가 여러개 있는 경우 ParameterizedTest 를 사용하면 편리하다. REFERENCE 1541번: 잃어버린 괄호#백준_1541 #백준_잃어버린_괄호" }, { "title": "(JPA)값 타입 컬렉션", "url": "/posts/(JPA)%EA%B0%92-%ED%83%80%EC%9E%85-%EC%BB%AC%EB%A0%89%EC%85%98/", "categories": "JPA", "tags": "JPA", "date": "2022-09-16 01:13:00 +0900", "snippet": "값 타입 컬렉션값 타입 컬렉션? 값 타입을 하나 이상 저장할 때 사용한다. @ElementCollection, @CollectionTable 어노테이션을 사용 테이터베이스는 컬렉션을 같은 테이블에 저장할 수 없어, 컬렉션 저장을 위한 별도의 테이블이 필요하다.값 타입 컬렉션 예제예제 엔티티 생성@Entitypublic class Member { ...", "content": "값 타입 컬렉션값 타입 컬렉션? 값 타입을 하나 이상 저장할 때 사용한다. @ElementCollection, @CollectionTable 어노테이션을 사용 테이터베이스는 컬렉션을 같은 테이블에 저장할 수 없어, 컬렉션 저장을 위한 별도의 테이블이 필요하다.값 타입 컬렉션 예제예제 엔티티 생성@Entitypublic class Member { @Id @GeneratedValue @Column(name = \"member_id\") private Long id; @Column(name = \"username\") private String username; @Embedded private Address homeAddress; @ElementCollection @CollectionTable(name = \"favorite_food\", joinColumns = @JoinColumn(name = \"member_id\") ) @Column(name = \"food_name\") private Set&lt;String&gt; favoriteFoods = new HashSet&lt;&gt;(); @ElementCollection @CollectionTable(name = \"address\", joinColumns = @JoinColumn(name = \"member_id\") ) private List&lt;Address&gt; addressHistroy = new ArrayList&lt;&gt;();} addressHistory 와 favoriteFoods 를 값 타입 컬렉션으로 생성 @ElementCollection: 값 타입 컬렉션으로 명시 @CollectionTable: 테이블 생성 설정 favoriteFoods 는 단 하나의 컬럼만 가지기 때문에 예외적으로 @Column 어노테이션을 사용할 수 있다.값 타입 컬렉션 저장 예제Member member = new Member();member.setUsername(\"member1\");member.setHomeAddress(new Address(\"homeCity\", \"street\", \"12345\"));member.getFavoriteFoods.add(\"치킨\");member.getFavoriteFoods.add(\"족발\");member.getFavoriteFoods.add(\"피자\");member.getAddressHistroy().add(new Address(\"old1\", \"street\", \"12345\"));member.getAddressHistroy().add(new Address(\"old2\", \"street\", \"12345\"));em.persist(member); 값 타입 저장 예제 값 타입 컬렉션은 따로 persist 할 필요없이, 값 타입을 가지고 있는 엔티티만 persist 하면 자동으로 persist 된다. 값 타입 컬렉션은 영속성 전이(CASCADE)와 고아 객체 제거 기능을 필수로 가지고 있다고 볼 수 있다. 값 타입 컬렉션 조회 예제Member member = new Member();member.setUsername(\"member1\");member.setHomeAddress(new Address(\"homeCity\", \"street\", \"12345\"));member.getFavoriteFoods.add(\"치킨\");member.getFavoriteFoods.add(\"족발\");member.getFavoriteFoods.add(\"피자\");member.getAddressHistroy().add(new Address(\"old1\", \"street\", \"12345\"));member.getAddressHistroy().add(new Address(\"old2\", \"street\", \"12345\"));em.persist(member);em.flush();em.clear();Member findMember = em.find(Member.class, member.getId()); 조회 코드Hibernate: select member0_.member_id, member0_.city, member0_.street, member0_.zipcode, member0_.username from Member member0_ where member0_.member_id=? 조회 후 발생된 쿼리를 살펴보면, Member 만 가지고 오는걸 확인할 수 있다. 위에 발생된 쿼리로 알 수 있는것은 값 타입 컬렉션은 전부 지연 로딩인걸 알 수 있다. 임베디드 타입의 Address 의 경우 지연 로딩으로 얻을 수 있는 이점이 없으므로 즉시 로딩된다.Member member = new Member();member.setUsername(\"member1\");member.setHomeAddress(new Address(\"homeCity\", \"street\", \"12345\"));member.getFavoriteFoods.add(\"치킨\");member.getFavoriteFoods.add(\"족발\");member.getFavoriteFoods.add(\"피자\");member.getAddressHistroy().add(new Address(\"old1\", \"street\", \"12345\"));member.getAddressHistroy().add(new Address(\"old2\", \"street\", \"12345\"));em.persist(member);em.flush();em.clear();Member findMember = em.find(Member.class, member.getId());List&lt;Address&gt; addressHistroy = findMeber.getAddressHistroy();for (Address address : addressHistroy) { System.out.println(\"address = \" + address.getCity());} 값 컬렉션 조회 로직 추가Hibernate: select member0_.member_id, member0_.city, member0_.street, member0_.zipcode, member0_.username from Member member0_ where member0_.member_id=? Hibernate: select addresshis0_.member_id, addresshis0_.city, addresshis0_.street, addresshis0_.zipcode, from Address addresshis0_ where addresshis0_.member_id=? 조회 후 쿼리를 살펴보면 이제 addressHistory 를 조회하는 것을 확인 할 수 있다.값 타입 컬렉션 수정 예제Member member = new Member();member.setUsername(\"member1\");member.setHomeAddress(new Address(\"homeCity\", \"street\", \"12345\"));member.getFavoriteFoods.add(\"치킨\");member.getFavoriteFoods.add(\"족발\");member.getFavoriteFoods.add(\"피자\");member.getAddressHistroy().add(new Address(\"old1\", \"street\", \"12345\"));member.getAddressHistroy().add(new Address(\"old2\", \"street\", \"12345\"));em.persist(member);em.flush();em.clear();Member findMember = em.find(Member.class, member.getId());/*값 타입은 불변해야 하기 때문에 이런식의 변경은 side-effect를 발생 시킬 가능성이 있다.findMember.getHomeAddress().setCity(\"newCity\"); */// 새로운 인스턴스로 통째로 갈아 끼워야 한다.Address old = findMember.getHomeAddress();findMember.setHomeAddress(new Address(\"newCity\", old.getStreet(), old.getZipcode()));// 치킨 -&gt; 짜장면findMember.getFavoriteFoods().remove(\"치킨\");findMember.getFavoriteFoods().add(\"짜장면\");// equals(), hashCode()가 제대로 구현되어 있어야 한다.findGetAddressHistroy().remove(new Address(\"old1\", \"street\", \"12345\"));findGetAddressHistroy().add(new Address(\"newCity1\", \"street\", \"12345\")); 값 타입안에 특정 값만 변경하는 것이 아니라, 전체 값을 갈아 끼워야 side-effect 로 부터 안전하다. favoriteFoods 값 타입 컬렉션은 변경이 아니라 삭제하고, 다시 저장해줘야 한다. 컬렉션만 변경해도 JPA 알아서 DB 쿼리를 날려 변경시켜 준다. 마치 영속성 전이가 된 것 처럼 동작한다. Hibernate: delete from address where member_id=? Hibernate: insert into address(member_id, city, street, zipcode) values (?, ?, ?, ?) Hibernate: insert into address(member_id, city, street, zipcode) values (?, ?, ?, ?) AddressHistory 값 타입 컬렉션을 수정할때 발생된 쿼리이다. 예상하기로는 remove() 한 old1 값을 가진 Address 만 delete 되고, newCity 가 insert 될 줄 알았는데 쿼리를 살펴보니 Address 를 통째로 삭제하고 남아있는 old2 와 newCity 가 insert 되는 것을 확인할 수 있다. DB를 보면 원했던 대로 이뤄졌으나, 왜 이렇게 동작되는지 의문이 생길 수 있다.값 타입 컬렉션의 제약 사항 값 타입은 Entity 와 다르게 식별자 개념이 없다. 값은 변경하면 추적이 어렵다. 값 타입 컬렉션에 변경 사항이 발생하면, 주인 Entity 와 연관된 모든 데이터를 삭제하고, 값 타입 컬렉션에 있는 현재 값을 모두 다시 저장한다. 값 타입 컬렉션을 매핑하는 테이블은 모든 컬럼을 묶어서 기본키를 구성해야 한다.(null과 중복 값이 허용되지 않는다.)값 타입 컬렉션 대안 실무에서는 상황에 따라 값 타입 컬렉션 대신에 일대다 또는 다대일 양방향 관계를 고려해야 한다. 일대다 관계를 위한 Entity 를 만들고, 여기에서 값 타입을 사용한다. 영속성 전이 + 고아 객체 제거를 사용해서 값 타입 컬렉션 처럼 사용한다. @Entity@Table(name = address)public class AddressEntity { @Id @GeneratedValue private Long id; @Embedded private Address address; public AddressEntity(String city, String street, String zipcode) { this.address = new Address(city, street, zipcode); }} 일대다 관계를 위한 별도의 엔티티 생성@Entitypublic class Member { @Id @GeneratedValue @Column(name = \"member_id\") private Long id; @Column(name = \"username\") private String username; @Embedded private Address homeAddress; @ElementCollection @CollectionTable(name = \"favorite_food\", joinColumns = @JoinColumn(name = \"member_id\") ) @Column(name = \"food_name\") private Set&lt;String&gt; favoriteFoods = new HashSet&lt;&gt;(); /* @ElementCollection @CollectionTable(name = \"address\", joinColumns = @JoinColumn(name = \"member_id\") ) private List&lt;Address&gt; addressHistroy = new ArrayList&lt;&gt;(); */ @OneToMany(cascae = CascadeType.ALL, orphanRemoval = true) @JoinColumn(name = \"member_id\") private List&lt;AddressEntity&gt; addressEntity = new ArrayList&lt;&gt;();} 기본 멤버 Entity 코드 수정 일대다 매핑(1 쪽(Member)에 외래키가 있다.)정리 값 타입 컬렉션은 정말 단순한 상황에서만 사용하는 것이 좋다.(지속 추적 및 변경이 필요 없어, 식별자가 필요하지 않는 상황) 거의 왠만한건 다 Entity 이다. 엔티티 타입의 특징 식별자가 존재한다. 생명 주기 관리 공유 가능하다. 값 타입의 특징 식별자가 없다. 생명주기를 엔티티에 의존한다. 공유하지 않는것이 안전하다.(불변 객체로 만들고, 복사해서 사용) 엔티티와 값 타입 컬렉션을 혼동해서 사용하면 큰일난다.REFERENCE 자바 ORM 표준 JPA 프로그래밍 - 기본편#JPA_값_타입_컬렉션" }, { "title": "(JPA)임베디드 타입", "url": "/posts/(JPA)%EC%9E%84%EB%B2%A0%EB%94%94%EB%93%9C-%ED%83%80%EC%9E%85/", "categories": "JPA", "tags": "JPA", "date": "2022-09-15 14:55:00 +0900", "snippet": "임베디드 타입임베디드 타입? 새로운 값 타입을 직접 정의 할 수 있다. JPA는 임베디드 타입이라 한다. 주로 기본 값 타입을 모아서 만들어서 복합 값 타입 이라고도 한다. int, String과 같은 값 타입임베디드 타입 사용법 @Embeddable: 값 타입을 정의하는 곳에 표시 @Embedded: 값 타입을 사용하는 곳에 표시 기본 ...", "content": "임베디드 타입임베디드 타입? 새로운 값 타입을 직접 정의 할 수 있다. JPA는 임베디드 타입이라 한다. 주로 기본 값 타입을 모아서 만들어서 복합 값 타입 이라고도 한다. int, String과 같은 값 타입임베디드 타입 사용법 @Embeddable: 값 타입을 정의하는 곳에 표시 @Embedded: 값 타입을 사용하는 곳에 표시 기본 생성자는 필수로 있어야 한다.임베디드 타입의 장점 재사용이 가능하다. 응집도가 높다. 해당 값 타입만 사용하는 의미 있는 메서드를 만들 수 있다. 임베디드 타입을 포함한 보든 값 타입은, 값 타입을 소유한 Entity의 생명주기에 의존한다.임베디드 타입과 테이블 매핑 임베디드 타입을 사용하던 안하던 DB 테이블과의 매핑은 달라지는게 없다. 객체와 테이블을 아주 세밀하게 매핑하는 것이 가능하다. 잘 설계한 ORM 애플리케이션은 테이블의 수보다 클래스의 수가 더 많다.임베디드 타입 예제 회원 엔티티는 이름, 근무 시작일, 근무 종료일, 주소 도시, 주소 번지, 주소 우편번호를 가진다. @Entitypublic class Member { @Id @GeneratedValue private Long id; @Column(name = \"username\") private String username; //기간 private LocalDateTime = startDate; private LocalDateTime = endDate; //주소 private String city; private String street; private String zipcode;} 위에 엔티티에서 묶을 수 있는 값 타입을 임베디드 타입으로 변경 할 수 있다.@Embeddablepublic class Period { private LocalDateTime = startDate; private LocalDateTime = endDate;} 기간에 대한 필드 값을 가지고 있는 객체@Embeddablepublic class Address { private String city; private String street; private String zipcode;} 주소에 대한 필드 값을 가지고 있는 객체@Entitypublic class Member { @Id @GeneratedValue private Long id; @Column(name = \"username\") private String username; //기간 @Embedded private Preiod preiod; //주소 @Embedded private Address address;} 임베디드 타입으로 변경 한 후의 멤버 엔티티임베디드 타입과 연관관계 임베디드 타입 안에는 또 다른 임베디드 타입이 있을 수 있고, 엔티티 또한 있을 수 있다.속성의 재정의@Entitypublic class Member { @Id @GeneratedValue private Long id; @Column(name = \"username\") private String username; //기간 @Embedded private Period period; //집주소 @Embedded @AttributeOverrides({ @AttributeOverride(name = \"city\", column = @Column(name = \"home_city\")), @AttributeOverride(name = \"street\", column = @Column(name = \"home_street\")), @AttributeOverride(name = \"zipcode\", column = @Column(name = \"home_zipcode\")) }) private Address homeAddress; //회사주소 @Embedded @AttributeOverrides({ @AttributeOverride(name = \"city\", column = @Column(name = \"work_city\")), @AttributeOverride(name = \"street\", column = @Column(name = \"work_street\")), @AttributeOverride(name = \"zipcode\", column = @Column(name = \"work_zipcode\")) }) private Address workAddress;} 한 엔티티에서 같은 값 타입을 사용하면 에러가 발생한다. 컬럼명이 중복 되기 때문 @AttributeOverrides, @AttributeOverride를 사용해서 컬럼명 속성을 재정의 하여 해결이 가능하다. 자주 사용하지는 않는다.임베디드 타입과 null@Embeddedprivate Period period = null; 임베디드 타입이 null이면 매핑한 컬럼값은 모두 null이다.REFERENCE 자바 ORM 표준 JPA 프로그래밍 - 기본편#JPA_임베디드_타입" }, { "title": "(JPA)즉시 로딩과 지연 로딩", "url": "/posts/(JPA)%EC%A6%89%EC%8B%9C-%EB%A1%9C%EB%94%A9%EA%B3%BC-%EC%A7%80%EC%97%B0-%EB%A1%9C%EB%94%A9/", "categories": "JPA", "tags": "JPA", "date": "2022-09-14 23:52:00 +0900", "snippet": "즉시 로딩과 지연 로딩지연 로딩 LAZY@Entitypublic class Member { @Id @GeneratedValue private Long id; @Column(name = \"USERNAME\") private String name; @ManyToOne(fetch = FetchType.LA...", "content": "즉시 로딩과 지연 로딩지연 로딩 LAZY@Entitypublic class Member { @Id @GeneratedValue private Long id; @Column(name = \"USERNAME\") private String name; @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = \"team_id\") private Team team; ...} Team 객체는 Proxy로 가져오게 된다. 실제 team을 사용하는 시점에 초기화를 통해 실제 Entity를 가져오게 된다. 비즈니스 로직 상 멤버와 팀을 함께 조회하는 경우가 적을 경우 사용하면 좋다.즉시 로딩 EAGEA@Entitypublic class Member { @Id @GeneratedValue private Long id; @Column(name = \"USERNAME\") private String name; @ManyToOne(fetch = FetchType.EAGEA) @JoinColumn(name = \"team_id\") private Team team; ...} member와 team을 조인을 통해 함께 조회한다. 비즈니스 로직 상 member와 team을 함께 조회하는 경우가 많을 경우 사용하면 좋다.프록시와 즉시 로딩 주의 가급적 지연 로딩만 사용하는 것이 좋다.(실무 경험 상) 즉시 로딩을 적용하면 예상하지 못한 SQL이 발생할 때가 있다. 수 많은 조인이 발생 할 수 있다. 즉시 로딩은 JPQL에서 N+1 문제를 일으킨다. @ManyToOne, @OneToOne은 기본이 즉시 로딩이다. -&gt; LAZY로 변경 @OneToMany, @ManyToMany는 기본이 지연 로딩이다.N+1 해결 방법Team teamA = new Team();team.setName(\"teamA\");em.persist(teamA);Team teamB = new Team();team.setName(\"teamB\");em.persist(teamB);Member memberA = new Member();memberA.setUsername(\"memberA\");memberA.setTeam(teamA);em.persist(memberA);Member memberB = new Member();memberB.setUsername(\"memberB\");memberB.setTeam(teamB);em.persist(memberB);em.flush();em.clear();List&lt;Member&gt; members = em.createQuery(\"select m from Member m\", Member.class).getResultList(); 위 코드에서 즉시 로딩 인 경우 member를 가져올때 team을 가져오는 쿼리가 하나 더 발생하기 때문에 N+1 문제가 발생한다. 해결방법 지연 로딩으로 변경한 후 fetch join 을 사용 @EntityGraph 어노테이션 사용 batch_fetch_size 설정 REFERENCE 자바 ORM 표준 JPA 프로그래밍 - 기본편#JPA_즉시로딩 #JPA_지연로딩" }, { "title": "(JPA)프록시", "url": "/posts/(JPA)%ED%94%84%EB%A1%9D%EC%8B%9C/", "categories": "JPA", "tags": "JPA", "date": "2022-09-13 23:33:00 +0900", "snippet": "프록시프록시 기초 em.find() vs em.getReference() em.find(): 데이터베이스를 통해서 실제 엔티티 객체를 조회 em.getReference(): 데이터베이스 조회를 미루는 가짜(프록시) 엔티티 객체 조회프록시 특징 실제 클래스를 상속 받아서 만들어진다. 실제 클래스와 겉 모양이 같다. 사용하는 입장에서는 진짜 객...", "content": "프록시프록시 기초 em.find() vs em.getReference() em.find(): 데이터베이스를 통해서 실제 엔티티 객체를 조회 em.getReference(): 데이터베이스 조회를 미루는 가짜(프록시) 엔티티 객체 조회프록시 특징 실제 클래스를 상속 받아서 만들어진다. 실제 클래스와 겉 모양이 같다. 사용하는 입장에서는 진짜 객체인지 프록시 객체인지 구분하지 않고 사용하면 된다.(이론상) 프록시 객체는 실제 객체의 참조(target)를 보관 프록시 객체를 호출하면 프록시 객체는 실제 객체의 메서드를 호출한다.프록시 객체의 초기화Member member = em.getReference(Member.class, \"id1\");member.getName(); getName() 초기화 요청 DB조회 실제 Entity 생성 target.getName() 영속성 컨텍스트를 통해 프록시에 값이 없을 경우 초기화를 요청하고, DB를 조회한 후 실제 Entity를 생성해준다. getName()을 두번 연속 요청할 경우에는 첫번째 요청에서만 초기화를 요청하고, 이후 요청에서는 생성된 Entity를 사용하여 초기화가 진행되지 않는다. 중간 정리 프록시 객체는 처음 사용할 때 한번 만 초기화가 진행된다. 프록시 객체를 초기화 할 때, 프록시 객체가 실제 Entity로 바뀌는 것이 아니라 초기화 되면 프록시 객체를 통해 실제 Entity에 접근이 가능해진다. 프록시 객체는 원본 Entity를 상속받으며, 따라서 타입 체크 시 주의를 해야한다.(== 비교 대신, instance of 를 사용) 영속성 컨텍스트에 이미 찾는 엔티티가 있으면, em.getReference() 를 호출해도 실제 Entity가 반환된다. 영속성 컨텍스트의 도움을 받을 수 없는 준 영속 상태일때는 프록시를 초기화 하면 문제가 발생한다. 하이버네이트는 org.hibernate.LazyInitializationException 예외를 발생시킨다. 프록시 예제Member member1 = new Member();member1.setUsername(\"member1\");em.persist(member1);em.flush();em.clear();Member realMember = em.find(Member.class, member1.getId());System.out.println(\"realMember = \" + realMember.getClass()); // 첫번째 클래스 출력Member proxyMember = em.getReference(Member.class, member1.getId());System.out.println(\"proxyMember = \" + proxyMember.getClass()); // 두번째 클래스 출력System.out.println(\"realMember == proxyMember: \" + (realMember == proxyMember)); // true? false? 첫번째 클래스 출력에서 실제 Member Entity가 출력되며, 두번째 출력 또한 프록시 객체가 출력되는 것이 아니라 실제 Member Entity가 출력된다. 그냥 보기에는 false 가 될것 같지만, ture 가 정답이다. 위에 처럼 동작되는 이유로는 1차 캐시안에 실제 Member Entity가 있는데, 굳이 프록시를 설정해서 사용하는것은 이점이 없기 때문이다. 같은 트랜젝션 안에서 같은 PK를 가지고 있는 객체 간의 == 비교는 true 가 반환되도록 매커니즘 설계 되어 있다. Member member1 = new Member();member1.setUsername(\"member1\");em.persist(member1);em.flush();em.clear();Member proxyMember = em.getReference(Member.class, member1.getId());System.out.println(\"proxyMember = \" + proxyMember.getClass()); // 첫번째 클래스 출력Member realMember = em.find(Member.class, member1.getId());System.out.println(\"realMember = \" + realMember.getClass()); // 두번째 클래스 출력System.out.println(\"realMember == proxyMember: \" + (realMember == proxyMember)); // true? false? 첫번째 클래스 출력에서는 당연히 Proxy가 나올것이고, 두번째 출력에서는 getReference() 를 사용한 조회가 아니기에 실제 Entity가 나올것이다. 하지만 JPA는 같은 트랜젝션 안에서 == 비교는 true 를 반환해야 하는데, 위에 같이 다르게 나올경우 true 를 반환할 수 없게 된다. 그렇기 때문에 두번째 클래스 출력 또한 Proxy 가 출력되게 된다.프록시 확인프록시 인스턴스의 초기화 여부 확인EntityManagetFactory emf = Persistence.createEntityManagerFactory(\"hello\");Member proxyMember = em.getReference(Member.class, member1.getId());System.out.println(\"proxyMember = \" + proxyMember.getClass());System.out.println(\"isLoaded = \" + emf.getPersistenceUnitUtil().isLoaded(proxyMember)); PersistenceUtil.isLoaded(Object entity) 초기화 된 경우 true 반환 아닌 경우 false 반환프록시 클래스 확인 방법System.out.println(\"proxyMember = \" + proxyMember.getClass()); 그냥 단순하게 찍어보는 방법 밖에 없다.프록시 강제 초기화Hibernate.initialize(proxyMember); // 강제 초기화 Hibernate가 제공 JPA 표준은 강제 초기화가 없다. REFERENCE 자바 ORM 표준 JPA 프로그래밍 - 기본편#JPA_프록시" }, { "title": "(JPA)상속관계 매핑", "url": "/posts/(JPA)%EC%83%81%EC%86%8D%EA%B4%80%EA%B3%84-%EB%A7%A4%ED%95%91/", "categories": "JPA", "tags": "JPA", "date": "2022-09-09 23:32:00 +0900", "snippet": "상속관계 매핑 관계형 데이터베이스는 상속 관계가 없다. 슈퍼타입, 서브타입 관계라는 모델링 기법이 객체 상속과 유사하다. 상속관계 매핑: 객체의 상속 구조와 DB의 슈퍼타입, 서브타입 관계를 매핑슈퍼, 서브타입 논리 모델을 물리 모델로 구현 각각 테이블로 변환 -&gt; 조인 전략 통합 테이블로 변환 -&gt; 단일 테이블 전략(JPA 기본 ...", "content": "상속관계 매핑 관계형 데이터베이스는 상속 관계가 없다. 슈퍼타입, 서브타입 관계라는 모델링 기법이 객체 상속과 유사하다. 상속관계 매핑: 객체의 상속 구조와 DB의 슈퍼타입, 서브타입 관계를 매핑슈퍼, 서브타입 논리 모델을 물리 모델로 구현 각각 테이블로 변환 -&gt; 조인 전략 통합 테이블로 변환 -&gt; 단일 테이블 전략(JPA 기본 전략) 서브타입 테이블로 변환 -&gt; 구현 클래스 마다 테이블을 두는 전략주요 어노테이션 @Inheritance(strategy = InheritanceType.XXX) JOINED: 조인 전략 SINGLE_TABLE: 단일 테이블 전략 TABLE_PER_CLASS: 구현 클래스 마다 테이블을 두는 전략 @DiscriminatorColumn(name = “DTYPE”) @Discriminator(“XXX”)조인 전략 @Inheritance(strategy = InheritanceType.JOINED)Item @DiscriminatorColumn 어노테이션을 명시 하지 않아도 정상적으로 작동하지만, 운영상 넣어주는 것이 좋다. 조인이 이뤄졌을때 DB 관점에서 어떤 테이블로의 조인이 이뤄지는지 명확하게 알기 어렵기 때문이다.```java@Entity@Inheritance(strategy = InheritanceType.JOINED)@DiscriminatorColumn(name = “DTYPE”)public abstract class Item { @Id @GeneratedValue private Long id; private String name; private int price;}``` Album@Entity@DiscriminatorValue(\"A\")public class Album extends Item { private String artist;}Movie@Entity@DiscriminatorValue(\"M\")public class Movie extends Item { private String director; private String actor;}Book@Entity@DiscriminatorValue(\"B\")public class Book extends Item { private String author; private String isbn;}조인 전략의 장점 테이블이 정규화 되어 있다. 외래 키 참조 무결성 제약조건을 활용할 수 있다. 저장 공간이 효율적이다.조인 전략의 단점 조회 시 조인을 많이 사용, 성능 저하 조회 쿼리가 복잡하다. 데이터 저장 시 INSERT SQL 2번 호출단일 테이블 전략 Item 엔티티에 붙어있는 @Inheritance(strategy = InheritanceType.XXX) 를 @Inheritance(strategy = InheritanceType.SINGLE_TABLE) 로 변경해주면 된다. @DiscriminatorColumn 어노테이션을 명시해주지 않아도, DTYPE 컬럼을 만들어 준다. 단일 테이블 전략에서는 DTYPE이 필수 하나의 테이블을 사용하기 때문에 값을 구분해줄 수 있는 컬럼이 필요하기 때문이다. 단일 테이블 전략의 장점 조인이 필요 없어 조회 성능이 좋다. 조회 쿼리가 매우 단순하다.단일 테이블 전략의 단점 자식 엔티티가 모든 컬럼에 대해 NULL 값을 허용해 줘야 한다. 단일 테이블에 모든 것을 저장하기 때문에 테이블이 커질 수 있으며, 상황에 따라 조회 성능이 느려질 수 있다.구현 클래스 마다 테이블을 생성하는 전략 Item 엔티티에 붙어있는 @Inheritance(strategy = InheritanceType.XXX) 를 @Inheritance(strategy = InheritanceType.TABLE_PER_CLASS) 로 변경해주면 된다. @DiscriminatorColumn 어노테이션은 필요가 없다. 사용하면 안되는 전략구현 클래스 마다 테이블을 생성하는 전략의 장점 서브 타입을 명확하게 구분해서 처리할 때 효과적이다. NOT NULL 제약조건을 사용 할 수 있다.구현 클래스 마다 테이블을 생성하는 전략의 단점 여러 자식 테이블을 함께 조회할 때 성능이 매우 안좋다. UNION SQL 을 사용하기 때문에 자식 테이블을 통합해서 쿼리 하기 어렵다. 변경이 매우 어렵다." }, { "title": "(JPA)다대다 매핑", "url": "/posts/(JPA)%EB%8B%A4%EB%8C%80%EB%8B%A4-%EB%A7%A4%ED%95%91/", "categories": "JPA", "tags": "JPA", "date": "2022-09-06 21:47:00 +0900", "snippet": "연관관계 매핑(다대다) 관계형 데이터베이스는 정규화된 테이블 2개로 다대다 관계를 표현할 수 없다. 연결 테이블을 추가해서 일대다, 다대일 관계로 풀어내야한다. 객체는 컬렉션을 사용해서 객체 2개로 다대다 관계가 가능하다.다대다 객체 연관관계(단방향)Product@Entitypublic class Product { @Id @Genera...", "content": "연관관계 매핑(다대다) 관계형 데이터베이스는 정규화된 테이블 2개로 다대다 관계를 표현할 수 없다. 연결 테이블을 추가해서 일대다, 다대일 관계로 풀어내야한다. 객체는 컬렉션을 사용해서 객체 2개로 다대다 관계가 가능하다.다대다 객체 연관관계(단방향)Product@Entitypublic class Product { @Id @GeneratedValue private Long id; private String name;}Member@Entitypublic class Member { @Id @GeneratedValue private Long id; @ManyToMany @JoinTable(name = \"member_product\") private List&lt;Product&gt; products = new ArrayList&lt;&gt;();}다대다 객체 연관관계(양방향)Product@Entitypublic class Product { @Id @GeneratedValue private Long id; private String name; @ManyToMany(mappedBy = \"products\") private List&lt;Member&gt; members = new ArrayList&lt;&gt;();}Member@Entitypublic class Member { @Id @GeneratedValue private Long id; @ManyToMany @JoinTable(name = \"member_product\") private List&lt;Product&gt; products = new ArrayList&lt;&gt;();}다대다 매핑의 한계 편리해 보이지만 실무에서 사용하지 못한다. 연결테이블이 단순하게 연결만 하고 끝나지 않는다. 연결테이블에 매핑 정보 외에 다른 정보를 넣을 수 없다.다대다 한계 극복 연결 테이블용 엔티티 추가 @ManyToMany를 @OneToMany 와 @ManyToOne 으로 분리하여 사용MemberProduct@Entitypublic class MemberProduct { @Id @GeneratedValue private Long id; @ManyToOne @JoinColumn(name = \"member_id\") private Member member; @ManyToOne @JoinColumn(name = \"product_id\") private Product product;}Member@Entitypublic class Member { @Id @GeneratedValue private Long id; @OneToMany(mappedBy = \"member\") private List&lt;MemberProduct&gt; memberProducts = new ArrayList&lt;&gt;();}Product@Entitypublic class Product { @Id @GeneratedValue private Long id; private String name; @OneToMany(mappedBy = \"product\") private List&lt;MemberProduct&gt; memberProducts = new ArrayList&lt;&gt;();}REFERENCE 자바 ORM 표준 JPA 프로그래밍 - 기본편#JPA_다대다 #연관관계_매핑" }, { "title": "(WEB)웹 소켓", "url": "/posts/(WEB)%EC%9B%B9-%EC%86%8C%EC%BC%93/", "categories": "WEB", "tags": "WEB", "date": "2022-09-02 23:47:00 +0900", "snippet": "Web SocketWeb Socket이란? 두 프로그램 간의 메시지를 교환하기 위한 통신 방법 중 하나이다. Client &lt;–Message–&gt; ServerWeb Socket의 특징양방향 통신(Full-Duplex) 데이터 송수신을 동시에 처리 할 수 있는 통신 방법 클라이언트와 서버가 서로에게 원할 때 데이터를 주고 받을 수 있다.실...", "content": "Web SocketWeb Socket이란? 두 프로그램 간의 메시지를 교환하기 위한 통신 방법 중 하나이다. Client &lt;–Message–&gt; ServerWeb Socket의 특징양방향 통신(Full-Duplex) 데이터 송수신을 동시에 처리 할 수 있는 통신 방법 클라이언트와 서버가 서로에게 원할 때 데이터를 주고 받을 수 있다.실시간 네트워킹(Real Time-Networking) 웹 환경에서 연속된 데이터를 빠르게 노출 여러 단말기에 빠르게 데이터를 교환웹 소켓 동작 방법(핸드 쉐이킹)연결 요청시 발생되는 HTTP Header MessageGET /chat HTTP/1.1Host: server.example.comUpgrade: websocketConnection: UpgradeSec-WebSocket-Key: dGhllHNhbXBsZSBub25jZQ==Origin: http://example.comSec-WebSocket-Protocol: chat, superchatSec-WebSocket-Version:13 GET /chat HTTP/1.1: 연결 수립 과정은 HTTP 프로토콜을 사용한다.(HTTP 버전은 1.1이상, 반드시 GET 메서드 사용) Host: 웹 서버 소켓의 주소 Upgrade: 현재 클라이언트, 서버, 전송 프로토콜 연결에서 다른 프로토콜로 업그레이드(변경)하기 위한 규약 Connection: Upgrade 헤더 필드가 명시되어 있는 경우, Upgrade 옵션이 지정되어 있는 Connection 헤더 필드도 함께 전송해야 한다. Sec-WebSocket-Key: 클라이언트와 서버가 서로를 구분할때 사용 Origin: 클라이언트의 주소 Sec-WebSocket-Protocol: 클라이언트가 요청하는 여러 서브 프로토콜을 의미(요청을 받으면 서버에서 지원하는 프로토콜이 무엇인지 반환해준다.)응답 메시지HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbk+xOo= 101 Switching Protocols: 웹소켓이 연결되었다는 의미 Sec-WebSocket-Accept: 클라이언트로 부터 받은 Sec-WebSocket-key를 사용하여 계산된 값(값이 일치하지 않으면 연결 x)웹 소켓 동작 방법(데이터 전송) 핸드 쉐이크 완료 이후 동작 핸드 쉐이크 과정에서 사용되던 HTTP 프로토콜이 ws 또는 wss(https처럼 보안을 위한 SSL이 적용된 프로토콜) 로 전환된다. Message(여러 frame이 모여서 구성하는 하나의 논리적 메세지 단위)단위를 사용 frame: communication에서 사용되는 가장 작은 단위의 데이터, 작은 헤더 + payload로 구성웹 소켓 프로토콜 특징 최초 접속에서만 HTTP 프로토콜 위에서 handshaking을 하기 때문에 http header 사용 별도의 포트가 존재하지 않으며, 기존 포트를 사용(80, 443) 프레임으로 구성된 메시지를 사용해 송수신 메시지에 포할 포함될 수 있는 교환 가능한 메시지는 텍스트와 바이너리웹 소켓의 한계 HTML5 이전의 기술로 구현된 서비스에서는 별도의 기술(Socket.io, SockJS)을 사용해야 한다. 웹 소켓은 문자열을 주고 받을 수 있게 해줄뿐이다. 문자열의 해석은 온전히 애플리케이션이 담당 형식이 정해져 있지 않아 애플리케이션에서 해석이 어렵다. 이 때문에 sub-protocols을 사용해서 주고 받는 메시지의 형태를 약속하는 경우가 많다. STOMP(Simple Text Oriented Message Protocol): sub-protoclo로 많이 사용되는 프로토콜 REFERENCE[10분 테코톡] 🧲코일의 Web Socket" }, { "title": "(JPA)일대일 매핑", "url": "/posts/(JPA)%EC%9D%BC%EB%8C%80%EC%9D%BC-%EB%A7%A4%ED%95%91/", "categories": "JPA", "tags": "JPA", "date": "2022-09-01 23:40:00 +0900", "snippet": "연관관계 매핑(일대일) 주 테이블이나 대상 테이블 중에 왜래 키 선택 가능 주 테이블에 외래 키 대상 테이블에 왜래 키 왜래 키에 데이터베이스 유니크 제약조건 추가일대일 객체 연관관계(단방향)Locker@Entitypublic class Locker {\t@Id\t@GeneratedValue\tprivate Long ...", "content": "연관관계 매핑(일대일) 주 테이블이나 대상 테이블 중에 왜래 키 선택 가능 주 테이블에 외래 키 대상 테이블에 왜래 키 왜래 키에 데이터베이스 유니크 제약조건 추가일대일 객체 연관관계(단방향)Locker@Entitypublic class Locker {\t@Id\t@GeneratedValue\tprivate Long id;\tprivate String name;}Member@Entitypublic class Member {\t...\t\t@OnetoOne\t@JoinColumn(name = \"locker_id\") // 안넣어 줘도 기본값으로 셋팅되나 기본값이 매우 지저분 하기 때문에 넣어주는게 좋다.\tprivate Locker locker;\t\t...}일대일 객체 연관관계(양방향)Locker@Entitypublic class Locker {\t@Id\t@GeneratedValue\tprivate Long id;\tprivate String name;\t@OnetoOne(mappedBy = \"locker\")\tprivate Member member;}Member@Entitypublic class Member {\t...\t\t@OnetoOne\t@JoinColumn(name = \"locker_id\") // 안넣어 줘도 기본값으로 셋팅되나 기본값이 매우 지저분 하기 때문에 넣어주는게 좋다.\tprivate Locker locker;\t\t...} 다대일 양방향이랑 유사하다. 다대일 양방향 매핑 처럼 외래 키가 있는 곳이 연관관계 주인 반대편은 mappedBy 적용 대상 테이블에 외래 키가 있는 단방향 관계는 JPA 에서 지원하지 않는다.DB테이블 입장에서 외래 키 위치 정해진 답은 없다. 어느 테이블이 외래 키를 가지던 양,단 방향은 제대로 관계가 맺어지고 동작도 잘 된다. 하지만, DB 입장에서 외래 키의 위치에 따라 trade-off 가 발생한다. 비즈니스 로직의 변경에 따라 어느곳에 두는게 추후에 좋을지 생각해보고 결정하는것이 좋다.하나의 Member가 여러 Locker를 갖는 경우 Member가 외래 키를 갖을때 하나의 Member가 여러 Locker를 가질 수 있도록 변경되면, 코드의 변경도 많아진다. 즉 변경 포인트가 많아 진다. Locker가 외래 키를 갖을때 지금은 하나의 Member가 하나의 Locker를 가지지만 추후에 만약 하나의 Member가 여러 Locker를 가질 수 있도록 변경된다면, 테이블 입장에서 일대다 매핑으로 변경하기 매우 쉽다.(유니크 제약 조건만 없애주면 끝) 단, 객체 입장에서 Member를 통해 Locker를 단방향으로 조회한다 하더라도, 어쩔수 없이 양방향으로 설계를 해야한다. Locker가 외래 키를 갖는 것이 변경에 유리하나의 Locker가 여러 Member를 갖는 경우 위에 상황에서 반대로 외래 키를 갖는 것이 변경에 유리ORM 입장에서 외래 키 위치Member가 외래 키를 갖는 경우 Member테이블을 많이 SELECT하는 경우 성능 상의 이점이 크고, 로직 작성이 쉽다. DBA 입장에서는 Member가 Locker를 가지고 있지 않을때 NULL값을 허용해 줘야하기 때문에 좋아하지 않을 수 있다. 각자 선호하는 방식에 따라 설계를 진행하는 것이 좋다.정리주 테이블에 외래 키 주 객체가 대상 객체의 참조를 가지는 것 처럼 주 테이블에 외래 키를 두고 대상 테이블을 찾음 객체지향 개발자가 선호 JPA 매핑이 편리하다. 장점: 주 테이블만 조회해도 대상 테이블에 데이터가 있는지 확인이 가능하다. 단점: 값이 없으면 외래 키에 NULL을 허용해줘야 한다.(DBA 입장에서 많이 안좋아하는 경우)대상 테이블에 외래 키 대상 테이블에 외래 키가 존재 전통적인 데이터베이스 개발자가 선호한다. 장점: 주 테이블과 대상 테이블을 일대일에서 일대다 관계로 변경할 때 테이블 구조를 유지하면서 변경이 가능하다. 단점: 프록시의 기능 한계로 지연 로딩으로 설정해도, 항상 즉시 로딩된다. REFERENCE 자바 ORM 표준 JPA 프로그래밍 - 기본편#JPA_일대일 #연관관계_매핑" }, { "title": "(JPA)일다대 매핑", "url": "/posts/(JPA)%EC%9D%BC%EB%8C%80%EB%8B%A4-%EB%A7%A4%ED%95%91/", "categories": "JPA", "tags": "JPA", "date": "2022-08-30 23:19:00 +0900", "snippet": "연관관계 매핑(1:N)일대다 객체 연관관계 1이 연관관계의 주인 권장되지 않는 매핑 방법Member@Entitypublic class Member {\t@Id\t@GeneratedValue\t@Column(name = \"member_id\")\tprivate Long id;\t@Column(name = \"username\")\tprivate String user...", "content": "연관관계 매핑(1:N)일대다 객체 연관관계 1이 연관관계의 주인 권장되지 않는 매핑 방법Member@Entitypublic class Member {\t@Id\t@GeneratedValue\t@Column(name = \"member_id\")\tprivate Long id;\t@Column(name = \"username\")\tprivate String username;} 멤버 객체Team@Entitypublic class Team {\t@Id\t@GeneratedValue\t@Column(name = \"team_id\")\tprivate Long id;\tprivate String name;\t@OneToMany\t@JoinColumn(name = \"team_id\")\tprivate List&lt;Member&gt; members = new ArrayList&lt;&gt;();} 팀 객체저장Member member = new Member();member.setUsername(\"member1\");em.persist(member);Team team = new Team();team.setName(\"teamA\");team.getMember().add(member);em.persist(team); DB에 저장은 문제 없이 잘 되나, Update Query 가 하나 더 발생된다.update memberset team_id=?where member_id=? 성능 상으로 아주 큰 문제는 아니지만, 어찌되었든 Query가 한번 더 발생하는 손실이 있고 추가적으로 JPA 숙련된 사람일지라도 코드만 보고 동작 방식을 한눈에 알아보기 어렵다.정리 연관관계 관리를 위해 추가적인 UPDATE SQL 실행 일대다 단반향은 1이 연관관계 주인 테이블 일대다에서는 항상 다(N) 쪽에 외래키가 있다. 객체와 테이블의 차이 때문에 반대편 테이블의 외래 키를 관리하는 특이한 구조 @JoinColumn을 필수적으로 사용해줘야 한다. 사용하지 않으면 조인 테이블 방식(중간에 연결 테이블을 하나 추가하는 방식)을 사용한다. JPA에서 자동적으로 Team_Member 중간 테이블을 생성 중간에 테이블이 하나 더 생성 되면서, 성능 상에도 조금의 문제가 있고 아무래도 관리해줘야 하는 테이블이 하나 더 생기기 때문에 관리하는데 어려움이 있을 수 있다. 단점 엔티티가 관리하는 외래 키가 다른 테이블에 존재결론 일대다 단방향 매핑 보다는 다대일 양방향 매핑을 사용하자.일대다 양방향?? 공식적으로는 존재 하지 않지만, 약간의 꼼수를 통해 만들 수 있다. @JoinColumn(insertable=false, updatable=false)사용 읽기 전용 필드를 사용해서 양방향 처럼 사용하는 방법 그냥 다대일 양방향을 쓰자.REFERENCE 자바 ORM 표준 JPA 프로그래밍 - 기본편 #JAP_일대다 #연관관계_매핑 " }, { "title": "(EC2)Spring수동배포", "url": "/posts/(EC2)Spring%EC%88%98%EB%8F%99%EB%B0%B0%ED%8F%AC/", "categories": "EC2", "tags": "EC2", "date": "2022-08-29 23:36:00 +0900", "snippet": "SpringBoot 프로젝트 수동으로 EC2에 배포하기EC2 인스턴스 생성(프리티어 기준)키페어 생성 기존 사용하는 키페어가 없다면, 새로 키페어를 생성 키페어가 유출되면 정말 큰일이 날 수 있으므로, 관리를 철저하게 해야한다.네트워크 설정 ssh 트래픽 허용(단, 보안설정을 통해 아무나 접속할 수 없도록 해야한다.) 0.0.0.0/0설정은 지...", "content": "SpringBoot 프로젝트 수동으로 EC2에 배포하기EC2 인스턴스 생성(프리티어 기준)키페어 생성 기존 사용하는 키페어가 없다면, 새로 키페어를 생성 키페어가 유출되면 정말 큰일이 날 수 있으므로, 관리를 철저하게 해야한다.네트워크 설정 ssh 트래픽 허용(단, 보안설정을 통해 아무나 접속할 수 없도록 해야한다.) 0.0.0.0/0설정은 지양해야한다.인바운드 규칙 편집 ssh/protocol:TCP/port:22/source: 허용할 IP MySQL/protocol:TCP/port:3306/source: 허용할 IP 사용자 지정 TCP/protocol:TCP/port:8080/source: 허용할 IPEC2 접속 키 페어를 생성하고, 받은 pem key 이 있는 라이브러리에서 ssh 명령어를 통해 EC2 접속ssh -i {키 페어 이름}.pem ubuntu@{인스턴스 아이피} 만약 접속이 안되면서 Error: Permission denied (publickey)이런 에러가 발생하면 pem key 파일의 권한을 변경하고 다시 시도해보자.chmod 400 ./키페어 이름.pemEC2에 MySQL과 jdk 설치 프로젝트에서 MySQL을 사용했으므로, EC2에도 MySQL을 설치해 주자. jdk11버전을 사용했으므로, 똑같이 jdk11을 설치해 주자.sudo apt updatesudo apt upgradesudo apt install mysql-serversudo apt install openjdk-11-jdk MySQL 설치가 완료되고 접속을하면 초기 설정을 하는데, 강력한 비밀번호 사용(보안엔 좋지만 너무 귀찮다.) 외에 다 yes를 해주면 된다.EC2 MySQL 유저 생성 및 권한 부여 MySQL설치를 완료하면, 앞으로 사용할 새로운 유저를 생성하고, 권한을 부여해줘야 한다.CREATE USER 'userId'@'%' IDENTIFIED BY '비밀번호'; // 유저 생성GRANT ALL PRIVILEGES ON DB명.* TO userId@'%'; // 모든 원격지에서 접속 권한 추가FLUSH PRIVILEGES; // 변경된 내용 반영EC2 MySQL 외부 접속 허용 MySQL 외부 접속을 허용해줘야 한다.sudo -i // root계정으로 변경cd /etc/mysql/my.cnf.d // mysql설정 파일 디렉토리로 이동vim mysqld.cnf // mysql 설정 파일 vim으로 열기 설정 파일을 vim으로 수정# bind-address = 127.0.0.1 // 주석처리# mysqlx-bind-address = 127.0.0.1 // 주석처리jar 배포application.yml파일 분리 local(로컬 설정), dev(배포 설정) 분리 DB접속 정보등 노출되면 안되는 정보를 감추기 위해 설정 정보 분리spring: datasource: url: jdbc:mysql://localhost:3306/{DB이름} driver-class-name: com.mysql.cj.jdbc.Driver username: ${ACCESS_ID}\t\t\t// 서버에서 jar파일 실행하면서, 값을 넣어주면 된다. password: ${ACCESS_PASSWORD}\t// 서버에서 jar파일 실행하면서, 값을 넣어주면 된다.server: port: 8080jar 파일 생성./gradlew bootJar gradle프로젝트 기준 build를 통해 jar파일 생성 만약 gradlew 실행 권한이 없다면 chmod +x gradlew로 권한을 설정해줘야 한다.jar파일 EC2로 전송 scp명령어를 통해 EC2로 jar파일 전송scp -i {pem key 파일 절대 경로}/{키페어 이름.pem} {jar파일 절대 경로}/{jar파일} ubuntu@{인스턴스 아이피}:/home/ubuntujar 파일 실행 EC2에 접속하여, 명령어를 통해 jar 파일 실행java -jar {jar 파일 이름}.jar --ACCESS_ID={username} --ACCESS_PASSWORD={password}\t// Foreground에서 실행nohup java -jar {jar 파일 이름}.jar --ACCESS_ID={username} --ACCESS_PASSWORD={password} 1&gt; /dev/null 2&gt;&amp;1 &amp; // Background에서 실행 &amp;와 nohup의 차이: &amp;로 실행하면, 로그아웃으로 세션과 연결이 종료되면 프로그램이 종료되고, nohup은 로그아웃을 하더라도 프로그램이 종료되지 않는다. 1&gt; /dev/null 2&gt;&amp;1 &amp;: 표준출력1은 /dev/null 파일로 리다이렉션하고, 표준에러2는 표준출력이 쓰이는 파일에 리다이렉션 하겠다는 뜻 /dev/null: 해당 파일은 항상 비어있으며, 여기로 전송된 데이터는 버려진다. 즉, 표준출력과 표준에러 모두 출력할 필요가 없다는 뜻백그라운드에서 실행중인 JVM 종료 jps 명령어를 통해 백그라운드에서 실행중인 JVM 프로세스의 PID를 알아낸 후 kill 명령어를 사용하면 종료시킬 수 있다.jps\t// 입력 시 아래와 같이 실행중인 JVM프로세스를 알수있다.2132 {jar파일 이름}.jar2860 Jpskill -9 2132\t// 입력하면 실행중인 jar파일을 종료시킬 수 있다." }, { "title": "(EC2)Nginx 배포", "url": "/posts/(EC2)Nginx%EB%B0%B0%ED%8F%AC/", "categories": "EC2", "tags": "EC2", "date": "2022-08-28 20:56:00 +0900", "snippet": "Nginx 배포하기(with.EC2)EC2(우분투) 기준 Nginx 배포npm 설치npm install # npm 설치npm -v # npm 설치 및 버전 확인node -v # node 버전 확인yarn 설치yarn install # yarn 설치yarn --version # yarn 설치 및 버전 확인npm 및 node 버전 npm과 node를 처...", "content": "Nginx 배포하기(with.EC2)EC2(우분투) 기준 Nginx 배포npm 설치npm install # npm 설치npm -v # npm 설치 및 버전 확인node -v # node 버전 확인yarn 설치yarn install # yarn 설치yarn --version # yarn 설치 및 버전 확인npm 및 node 버전 npm과 node를 처음 설치했을때 최신버전이 아닌 예전 버전이 설치된다. npm bulid를 했을때 지속적인 오류가 발생한다면, npm 버전을 6버전 이상 노드를 14버전 이상으로 업그레이드 후 다시 build 시도 EC2 우분투 내에서 npm 및 node 버전을 업그레이드 하는것은 매우 번거로운 작업이다. 쉽게 하기 위해 외부 링크에서 npm 및 node버전 업글을 위한 스크립트가 짜여있는 파일을 받은 후 스크립트를 실행하여, 업그레이드 진행curl -sL https://deb.nodesource.com/setup_14.x -o nodesource_14_setup.sh # npm및 node버전 업글을 위한 스크립트 다운sudo bash nodesource_14_setup.sh # 스크립트 실행Nginx 설치sudo apt install nginxnginx -v # 설치 및 버전 확인프론트 Build 파일 클론 Nginx에 올릴 프론트 파일을 깃헙에서 가져오자.git clone -b {브랜치 이름} --single-branch {리포지토리 주소}npm build 가져온 프론트 파일을 npm으로 build를 해준다. build를 하면 build 라이브러리가 생성되는데 이 build 라이브러리 경로를 잘 설정해줘야 문제없이 Nginx를 배포할 수 있다.npm start # npm 실행npm run build # npm을 통한 buildNginx 설정cd /etc/nginx # nginx 설정을 위해 이동cd sites-abailable # 라이브러리로 이동vi {파일이름}.conf # 설정을 위한 파일을 vi로 생성과 동시에 열기server { listen 80; location / { try_files $uri $uri/ /index.html; index index.html index.htm; root {아까 생성한 build 라이브러리 경로}; } location /api { proxy_pass http://localhost:8080; }}sudo ln -s /etc/nginx/sites-available/{설정 파일 이름}.conf /etc/nginx/sites-enabled # vi 종료 후 심볼릭 링크 디렉토리 생성vi {설정 파일 이름}.conf # 심볼릭 디렉토리로 이동하여 설정 파일 이름과 동일한 파일을 만들고 수정ll # {설정 파일 이름}.conf -&gt; /etc/nginx/sites-available/{설정 파일 이름}.conf -&gt; 링크 연결 확인server { listen 80; location / { try_files $uri $uri/ /index.html; index index.html index.htm; root {build 라이브러리 경로}; } location /api { proxy_pass http://localhost:8080; }}Nginx 실행sudo service nginx configtest # Nginx 설정파일 테스트* Testing nginx configuration [ OK ] # 라고 나오면 테스트 성공sudo service nginx start # Nginx 실행sudo service nginx stop # Nginx 중지sudo service nginx restart # Nginx 재실행sudo service nginx reload # Nginx 서버를 종료하지 않고 설정 파일만 다시 적용 위에 명령어를 상황에 맞게 사용하여 Nginx를 실행하면 된다.배포 후기 빌드 및 배포에 성공을 하였지만, 정확하게 무엇을 위한 설정이였고 어떤 원리로 작동되는지 아직 다 공부하지 못했다. Nginx에 대해 좀 더 공부할 필요가 있을거 같다." }, { "title": "(일일회고)22.08.23", "url": "/posts/(%EC%9D%BC%EC%9D%BC%ED%9A%8C%EA%B3%A0)22.08.23/", "categories": "일일회고", "tags": "일일회고", "date": "2022-08-23 23:50:00 +0900", "snippet": "👨‍💻오늘 공부한 내용 JPA 기본편 - 연관관계 매핑🌀부족한 내용 DP 알고리즘 너무 하기 싫지만 안할 수 없으니 재미를 붙이도록 노력해봐야겠다. 😆좋았던 점 양방향 편의 메서드와 연관관계 주인등 issue-tracker 프로젝트를 진행하면서, 연관관계 매핑에 대해 의문이 들었던 점이 해소 되어 좋았다.🥺아쉬운 점 조...", "content": "👨‍💻오늘 공부한 내용 JPA 기본편 - 연관관계 매핑🌀부족한 내용 DP 알고리즘 너무 하기 싫지만 안할 수 없으니 재미를 붙이도록 노력해봐야겠다. 😆좋았던 점 양방향 편의 메서드와 연관관계 주인등 issue-tracker 프로젝트를 진행하면서, 연관관계 매핑에 대해 의문이 들었던 점이 해소 되어 좋았다.🥺아쉬운 점 조금씩 집중력이 흐트러 지는거 같다. 새로운 자극이 필요👨‍💻내일 공부할 내용 및 개선 사항 이전에 공부한 내용 정리해서 포스팅하기 JAP 기본편 - 프록시와 연관관계 관리 issue-tracker 리펙터링 사이드 프로젝트 코드 뜯어보기 " }, { "title": "(JPA)연관관계 매핑", "url": "/posts/(JPA)%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84-%EB%A7%A4%ED%95%91/", "categories": "JPA", "tags": "JPA", "date": "2022-08-23 22:25:00 +0900", "snippet": "JPA 연관관계 매핑객체 멤버(N) 팀(1) 연관관계 매핑 미설정모델링 객체를 테이블에 맞추어 모델링 참조 대신에 외래 키를 그대로 사용 객체@Entitypublic class Member { @Id @GeneratedValue private Long id; @Column(...", "content": "JPA 연관관계 매핑객체 멤버(N) 팀(1) 연관관계 매핑 미설정모델링 객체를 테이블에 맞추어 모델링 참조 대신에 외래 키를 그대로 사용 객체@Entitypublic class Member { @Id @GeneratedValue private Long id; @Column(name = \"USERNAME\") private String username; @Column(name = \"TEAM_ID\") private Long teamId;} 멤버 객체@Entitypublic class Team { @Id @GeneratedValue @Column(name = \"TEAM_ID\") private Long id; private String name;} 팀 객체객체 저장// 팀 저장Team team = new Team();team.setName(\"TeamA\");em.persist(team);// 멤버 저장Member member = new Member();member.setName(\"member1\");member.setTeamId(team.getId());em.persist(member);Member Table MEMBER_ID TEAM_ID USERNAME 1 1 member1 Team Table TEAM_ID NAME 1 TeamA 객체 조회// 멤버 조회Member findMember = em.find(Member.class, member.getId());// 멤버의 팀 아이디 가져오기Long findTeamId = findMember.getTeamId();// 멤버가 해당하는 팀 조회Team findTeam = em.find(Team.class, findTeamId); 연관관계가 존재하지 않아, 필요할때 마다 JPA를 통해 계속 조회가 이뤄진다. 객체지향스럽지 않다. 테이블은 외래키로 조인을 사용해서 연관된 테이블을 찾고, 객체는 참조를 사용해서 연관된 객체를 찾는다. 테이블과 객체간에는 이런 큰 차이점이 있다. 연관관계 매핑 설정(단방향)모델링 객체 지향 모델링객체@Entitypublic class Member { @Id @GeneratedValue private Long id; @Column(name = \"USERNAME\") private String username;\t@ManyToOne @JoinColumn(name = \"TEAM_ID\") private Team team;} Member N 이고, Team이 1 이기 때문에 ManyToOne 연관관계를 설정해준다. Team_ID(FK) 를 매핑해줘야 하기 때문에 JoinColumn 을 사용해서 매핑할 컬럼을 지정해준다. 위와 같이 설정해 주면 매핑이 끝나게 된다. Team 객체 같은 경우는 변경 사항이 없다.객체 저장// 팀 저장Team team = new Team();team.setName(\"TeamA\");em.persist(team);// 멤버 저장Member member = new Member();member.setName(\"member1\");member.setTeam(team);em.persist(member); team의 id 값을 저장하는 것이 아니라 team 객체 자체를 저장연관관계 매핑 설정(양방향) 양방향으로 객체 탐색이 가능 매핑은 단방향이 좋다.DB 테이블 방향이 따로 존재 하지 않는다, FK, PK의 조인을 통해 양쪽으로 조회가 가능 테이블 연관관계 회원 &lt;-&gt; 팀의 연관관계 1개(양방향) 객체 객체 연관관계 객체의 양방향 관계는 사실 양방향 관계가 아니라 서로 다른 단방향 관계 2개다. 회원 -&gt; 팀 연관관계 1개(단방향) 팀 -&gt; 회원 연관관계 1개(단방향) 위에 단방향 매핑으로는 member에서는 team을 조회 할 수 있으나, team에서는 member를 조회 할 수 없다. 객체와 DB 테이블의 가장 큰 차이점 @Entitypublic class Team { @Id @GeneratedValue @Column(name = \"TEAM_ID\") private Long id; private String name; @OneToMany(mappedBy = \"team\") private List&lt;Member&gt; members = new ArrayList&lt;&gt;();} Team 객체에 member를 저장 할 수 있도록 List 생성 Member -&gt; Team은 다대일, Team -&gt; Member 일대다 이기 때문에 @OneToMany 매핑 설정을 해준다. 일대다 매핑에서 어떤 객체랑 연결되어 있는지 나타내주기 위해 mappedBy = \"team\"을 설정 Member 객체에 존재하는 Team의 FK가 저장되는 필드 명을 mappedBy 로 지정해주면 된다. Member 객체는 변경 사항이 없다.객체 조회...Member findMember = em.find(Member.class, member.getId());List&lt;Member&gt; members = findMember.getTeam().getMembers();for (Member m : members) { System.out.println(\"m = \" + m.getUsername());} 멤버를 조회하고, 멤버를 통해 다시 팀을 조회 한 후 해당 팀에 속해 있는 멤버를 조회 할 수 있게되었다. 한쪽 방향에서만 조회가 되는것이 아니라 양방향으로 조회가 가능연관관계 주인 Member 클래스 혹은 Team 클래스에서 서로 참조 하고 있는 두개의 필드 값중 하나로 외래 키를 관리해야 한다. 객체의 두 관계중 하나를 연관관계의 주인으로 지정 연관관계의 주인만이 외래 키를 관리(등록, 수정) 주인이 아닌쪽은 readOnly 주인은 mappedBy 속성을 사용하지 않는다. 주인이 아니면 mappedBy 속성으로주인 지정 누구를 주인으로? 외래키가 있는 객체를 주인으로 설정(영한님 가이드) 위의 예제에서는 Member를 주인으로 설정 양방향 매핑에서 가장 많이 하는 실수Team team = new Team();team.setName(\"TeamA\");team.getMembers().add(member); // 문제를 일으키는 코드em.persist(team);Member member = new Member();member.setName(\"member1\");/**/em.persist(member); 연관관계 주인에 값을 입력하지 않았다. 3번째 라인에 작성되어 있는 코드는 연관관계 주인이 아닌곳에 값을 넣어 주기 때문에 DB에서 변경이 일어나지 않는다. 9번째 라인에 member.setTeam(team); 코드를 추가해서 연관관계 주인에 값을 넣어 줘야 DB에 Insert 된다. 둘다 넣어도 상관 없지만, 주인의 값을 넣어주는 코드는 절때 빠지면 안된다.Team team = new Team();team.setName(\"TeamA\");em.persist(team);Member member = new Member();member.setName(\"member1\");member.setTeam(team);em.persist(member);em.flush();em.clear();Team findTeam = em.find(Team.class, team.getId());List&lt;Member&gt; members = findTeam.getMembers();for (Member m : members) { System.out.println(\"m = \" + m.getUsername());} JPA 입장에서는 주인에만 값을 넣어줘도 상관 없지만(flush, clear가 이뤄진 경우), 객체 관점에서는 둘다 값을 넣어주는게 좋다. flush와 clear가 제대로 이뤄지지 않으면, 영속성 컨텍스트에서 1차 캐쉬의 값을 조회해 오기 때문에 값이 없다. 분명 Team객체에 존재하는 members에 따로 member를 넣어 주지 않았지만, 조회를 하면 조회가 잘 된다. members의 데이터를 실제로 사용하는 시점에 query를 하나 사용해서 연관되어 있는 member 데이터를 전부 가져옴 늘 양방향 편의 메서드가 없어도 데이터가 잘 나오는데 왜 사용하는 거지? 라는 의문점이 있었는데 한방에 해결되었다. ​ REFERENCE자바 ORM 표준 JPA 프로그래밍 - 기본편자바 ORM 표준 JPA 프로그래밍 - 4장" }, { "title": "(CS)프로세스 스케줄링", "url": "/posts/(CS)%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81/", "categories": "CS", "tags": "CS", "date": "2022-08-20 22:25:00 +0900", "snippet": "프로세스 스케줄링배치 처리 시스템배치 처리 시스템이란? 자동으로 다음 응용 프로그램이 이어서 실행될 수 있도록 하는 시스템 Application이 등록된 시간 순서대로 실행된다.(순차적인 실행) 큐를 생각하면 이해하기 쉽다. Application의 실행 시간에 따라 대기시간이 정해진다. 우선도가 낮은 응용프로그램이 실행되고, 우...", "content": "프로세스 스케줄링배치 처리 시스템배치 처리 시스템이란? 자동으로 다음 응용 프로그램이 이어서 실행될 수 있도록 하는 시스템 Application이 등록된 시간 순서대로 실행된다.(순차적인 실행) 큐를 생각하면 이해하기 쉽다. Application의 실행 시간에 따라 대기시간이 정해진다. 우선도가 낮은 응용프로그램이 실행되고, 우선도가 높은 응용프로그램이 실행되면 우선도가 높음에도 불구하고 앞에 실행된 응용프로그램이 종료될때 까지 대기해야하는 단점이 있다.(대표적인 문제) 동시성과 다중사용에도 문제가 많다. 위에 여러 문제점을 해결하기 위해 멀티 프로그래밍/시분할 시스템이 등장하게 되었다.시분할 시스템시분할 시스템이란? 다중 사용자 지원을 위해 컴퓨터 응답 시간을 최소화하는 시스템 응용 프로그램이 CPU를 점유하는 시간을 잘게 쪼개어 실행될 수 있도록 하는 시스템멀티 태스킹멀티 태스킹이란? 단일 CPU에서, 여러 응용 프로그램이 동시에 실행되는 것 처럼 보이도록 하는 시스템멀티 태스킹과 멀티 프로세싱 멀티 태스킹: 단일 CPU에 여러 프로그램을 잘게 쪼개서 동시에 실행되는 것 처럼 보이도록 하는 시스템 멀티 프로세싱: 다중 CPU에 하나의 프로그램을 병렬로 실행시켜 실행속도를 극대화시키는 시스템멀티 프로그래밍멀티 프로그래밍이란? 최대한 CPU를 많이 활용하도록 하는 시스템 시간 대비 CPU활용도를 높이자. 응용 프로그램을 짧은 시간 안에 실행을 완료 시킬 수 있다. 응용 프로그램은 온전히 CPU를 쓰기 보다, 다른 작업을 중간에 필요로 하는 경우가 많다. 파일을 읽는 작업 등등 중간에 시간이 많이 소요되는 작업이 진행될때 CPU는 해당 응용프로그램 말고, 다른 응용 프로그램을 번갈아 실행하면서 대기시간을 단축시키고 그로 인해 응용 프로그램을 짧은 시간 안에 실행을 완료 시킬 수 있게 된다.프로세스프로세스란? 실행 중인 프로그램을 프로세스라고 한다. 프로세스: 메모리에 올려저서, 실행 중인 프로그램 프로그램: 어떤 작업을 위해 운영체제 위에서 실행할 수 있는 파일 ex: 웹 브라우저, 워드 프로세서, 카카오톡 등 프로세서: 프로세스가 동작될 수 있도록 하는 하드웨어(CPU) 프로세서는 한순간에 하나의 프로세스만 실행 가능 프로세스라는 용어는 작업, task, jab이라는 용어와 혼용 응용 프로그램 != 프로세스 응용 프로그램은 여러 개의 프로세스로 이루어질 수 있다. 하나의 응용 프로그램은 여러 개의 프로세스가 상호작용을 하면서 실행될 수도 있다.스케줄링스케줄링이란? 프로세스가 생성되어 실행될 때 필요한 시스템의 여러 자원을 해당 프로세스에게 할당하는 작업. 대기 시간은 최소화 하고, 최대한 공평하게 처리하는 것을 목적으로 한다.스케줄러의 종류 Long-Term Scheduler 장기 스케줄러 Short-Term Scheduler 단기 스케줄러 Medium-Term Scheduler 중기 스케줄러스케줄링 알고리즘FIFO 스케줄링 가장 간단한 스케줄링 알고리즘 프로세스 실행 요청 순서에 따라 실행 배치 처리 시스템 FCFS 스케줄러라고 불리기도 한다. Queue 자료 구조를 사용해서 구현최단 작업 우선(SJF) 스케줄링 실행 시간이 가장 짧은 프로세스부터 실행시키는 스케줄링 알고리즘우선순위 기반 스케줄링 Priority-Based 스케줄러 우선순위가 높은 프로세스부터 실행시키는 스케줄링 알고리즘 정적 우선순위: 프로세스마다 우선순위를 미리 지정 동적 우선순위: 스케줄러가 상황에 따라 우선순위를 동적으로 변경 Round Robin 스케줄러 시분할 시스템을 위해 설계된 선점형 스케줄링의 하나로서, 프로세스 사이의 우선순위를 두지 않고 순서대로 시간단위로 CPU를 할당하는 방식의 알고리즘프로세스 상태와 스케줄링프로세스 상태 running state: 현재 CPU에서 실행중인 상태 ready state: CPU에서 실행 대기중인 상태 block state: 특정 이벤트 발생 대기 상태(I/O 작업)프로세스 상태에 따른 스케줄링 알고리즘 Ready State Queue Running State Queue Block State Queue 3가지 상태에 따른 Queue를 각각 만들고, 상태에 따라 각각 Queue에 저장선점형과 비선점형 스케줄러선점형 스케줄러란? 하나의 프로세스가 다른 프로세스 대신 CPU(프로세서)를 차지할 수 있다. 프로세스 running중에 스케줄러가 이를 중단시키고, 다른 프로세스로 교체 가능하다.비선점형 스케줄러란? 하나의 프로세스가 끝나지 않으면 다른 프로세스는 CPU(프로세서)를 사용할 수 없다. 프로세스가 자발적으로 blocking 상태로 들어가거나, 실행이 끝났을 때만 다른 프로세스로 교체가 가능하다.인터럽트인터럽트란? CPU가 프로그램을 실행하고 있을때, 입출력 하트웨어 등의 장치나 또는 예외상황이 발생하여 처리가 필요할 경우 CPU에 알려서 처리하는 기술인터럽트가 필요한 이유? 이미지 출처: https://www.fun-coding.org/interrupt.html 선점형 스케줄러에서 다른 프로세스로 교체하기 위해 지금 실행중인 프로세스를 중단시킨다. 현재 진행중인 프로세스를 중단시키기 위해서는 스케줄러 코드가 실행되어야한다. 이때 사용하는 것이 인터럽트다. 예외 상황 핸들링 입출력 하드웨어의 등의 장치 문제 또는 예외상황이 발생할 경우 CPU에 알려줘야 처리가 가능하다. 인터럽트 처리 예 CPU가 프로그램을 실행하고 있을때 입출력 하드웨어 등의 장치 이슈 발생 파일처리가 끝났다는 것을 운영체제에 알려주기 운영체제는 해당 프로세스를 block state에서 실행 대기 상태로 프로세스 상태를 변경 예외 상황이 발생 0으로 나누는 계산이 발생해서, 예외 발생을 운영체제에 알려주기 운영체제가 해당 프로세스 실행 중시/에러 표시 class Test { public static void main(String[] args) { System.out.println(\"인터럽트 테스트\"); int a; int b = 0; a = 100 / b; System.out.println(a); }} 인터럽트 테스트 문구는 정상적으로 출력 컴파일 단계에서 100 / 0 부분에서 문제가 있는지 알 수가 없다. 프로그램이 실행되고 100 / 0 부분에서 예외가 발생하면서, 프로그램이 종료된다. Exception in thread “main” java.lang.ArithmeticException: / by zero at Test.main(Test.java:6) 인터럽트의 종류 타이머 인터럽트 선점형 스케줄러를 처리하기 위해 필요 하드웨어로 부터 일정 시간마다 타이머 인터럽트를 운영체제에 알려준다. 일정 시간마다 프로세스의 교체를 위해 필요 입출력(IO) 인터럽트 키보드, 마우스 등등 입출력 하드웨어 장치로부터 신호를 받았을때 처리하는 인터럽트 내부 인터럽트(소프트웨어 인터럽트) 주로 프로그램 내부에서 잘못된 명령 또는 잘못된 데이터 사용 시 발생 0으로 나누었을때 Overflow/Underflow가 발생할때 잘못된 명령 또는 허용되지 않는 공간 접근 시 외부 인터럽트(하드웨어 인터럽트) 주로 하드웨어에서 발생되는 이벤트 전원 이상 기계 문제 키보드 등 IO관련 이벤트 Timer 이벤트 프로세스와 컨텍스트 스위칭PCB 프로세스가 실행중인 상태를 캡쳐/구조화하여 저장 저장되는 내용 Process ID Register값 (SP, PC) Scheduling Info (Process State) Memory Info (메모리 사이즈 Limit) 등등 컨텍스트 스위칭(문맥 교환) 이미지 출처: https://www.fun-coding.org/contextswitching.html 하나의 프로세스가 CPU를 사용 중인 상태에서 다른 프로세스가 CPU를 사용하도록 하기 위해, 이전의 프로세스의 상태를 보관하고 새로운 프로세스의 상태를 적재하는 작업 이전 프로세스의 상태를 보관하는 곳이 바로 PCB이다. 운영체제에 따라 PCB를 저장하는 위치는 달라질 수 있다. 디스패치: ready상태의 프로세스를 running상태로 변경하는 것 컨텍스트 스위칭은 굉장히 빠른 속도로 이루어진다.프로세스간 커뮤니케이션(IPC) 원칙적으로는 프로세스간 접근이 허용되지 않는다.IPC란? 프로세스간 통신 방법을 제공한다.프로세스간 통신이 왜 필요할까? 성능을 높이기 위해 여러 프로세스를 만들어서 동시 실행 위와 같은 작업을 하기 위해 프로세스의 상태를 확인 및 데이터 송수신이 필요 예를 들어 fork() 시스템 콜이 있다. fork() 함수로(C언어) 프로세스 자신을 복사해서 새로운 프로세스로 만들 수 있다. 프로세스를 fork()해서 여러 프로세스를 동시에 실행 시킬 수 있다. CPU의 코어개수 만큼 프로세스를 동시에 실행 가능(병렬처리) 각 프로세스에서 처리한 데이터를 모아서 결과를 반환해야 하므로, 프로세스간 통신이 필요하다. Reference[10분 테코톡] 👩‍💻👨‍💻 쪼밀리와 오구의 Process vs Thread운영체제란?스케줄러의 종류" }, { "title": "(일일회고)22.08.18", "url": "/posts/(%EC%9D%BC%EC%9D%BC%ED%9A%8C%EA%B3%A0)22.08.18/", "categories": "일일회고", "tags": "일일회고", "date": "2022-08-18 23:50:00 +0900", "snippet": "👨‍💻오늘 공부한 내용 게시판 만들어 보기 드디어 완료 생각보다 오래걸리기도 했고, 참 단순하고 기본적인 내용인데 아직 이해 안가는 부분이 조금씩 있다. 알고리즘 스터디 문제풀이 프로그래머스-체육복 🌀부족한 내용 자바 기본기가 아직 많이 부족한거 같다. JPA는 해도해도 할때마다 어렵다.😆좋았...", "content": "👨‍💻오늘 공부한 내용 게시판 만들어 보기 드디어 완료 생각보다 오래걸리기도 했고, 참 단순하고 기본적인 내용인데 아직 이해 안가는 부분이 조금씩 있다. 알고리즘 스터디 문제풀이 프로그래머스-체육복 🌀부족한 내용 자바 기본기가 아직 많이 부족한거 같다. JPA는 해도해도 할때마다 어렵다.😆좋았던 점 게시판 만들어 보기 드디어 완료🥺아쉬운 점 코드를 완전히 다 이해하지는 못한점👨‍💻내일 공부할 내용 및 개선 사항 강의 들으면서 스스로 설명하지 못한 내용 Map과 MultiValueMap 차이 ObjectMapper의 각 메서드 활용법 findById와 getReferenceById의 차이점 JPA 강의 복습 엔티티 매핑에서 고급 매핑까지 게시판 만들어보기 완성 코드 하나씩 뜯어보기" }, { "title": "(CS)프로세스 구조", "url": "/posts/(CS)%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EA%B5%AC%EC%A1%B0/", "categories": "CS", "tags": "CS", "date": "2022-08-09 23:50:00 +0900", "snippet": "프로세스 구조프로세스 구조프로세스의 일반적인 구조 text(CODE): 코드 data: 전역변수 stack: 함수를 호출할 때마다 지역 변수, 매개변수와 리턴값 등이 쌓인다. heap: 코드에서 동적으로 만들어지는 데이터EBP(Extended Base Pointer)와 ESP(Extended Stack Pointer) ESP: 현재 스택의 가...", "content": "프로세스 구조프로세스 구조프로세스의 일반적인 구조 text(CODE): 코드 data: 전역변수 stack: 함수를 호출할 때마다 지역 변수, 매개변수와 리턴값 등이 쌓인다. heap: 코드에서 동적으로 만들어지는 데이터EBP(Extended Base Pointer)와 ESP(Extended Stack Pointer) ESP: 현재 스택의 가장 위에 들어있는 데이터를 가리키고 있는 포인터 ESP는 다음 DATA를 PUSH 할 위치가 아니라 다음에 POP 했을때 뽑아낼 데이터의 위치를 가리킨다. EBP: 현재 스택에 가장 바닥을 가리키는 포인터 새로운 함수가 호출될 때마다 EBP 레지스터 값이 지금까지 사용했던 Stack 꼭대기의 위에 위치하게 되고 새로운 Stack 시작 EBP는 새로운 함수가 호출되거나 현재 실행중인 함수가 종료되어 리턴될 때마다 값이 달라진다. Stack#include &lt;stdio.h&gt;void exFunc(int data) { int temp; temp = data;}int main(int argc, char const *argv[]){ exFunc(1); return 0;}Stack Overflow 소프트웨어에서 스택 오버플로(영어: stack overflow)는 스택 포인터가 스택의 경계를 넘어설 때 일어난다. 호출 스택은 제한된 양의 주소 공간을 이루며 대개 프로그램 시작 시 결정된다.프로그램이 호출 스택에서 이용 가능한 공간 이상을 사용하려고 시도할 때, 스택이 오버플로(overflow)된다고 하며 이 경우 일반적으로 프로그램 충돌이 발생하게 된다 (위키백과)Heap#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main() { int *data; data = (int *) malloc(sizeof(int)); *data = 1; printf(\"%d\\n\", *data); return 0;}#include &lt;stdlib.h&gt;void *malloc(size_t size); malloc() 함수 malloc() 함수는 프로그램이 실행 중일 때 사용자가 직접 힙 영역에 메모리를 할당할 수 있게 해줍니다. malloc() 함수는 인수로 할당받고자 하는 메모리의 크기를 바이트 단위로 전달 받는다.#include &lt;stdlib.h&gt;void free(void *ptr); free() 함수 힙 영역에 할당받은 메모리 공간을 다시 운영체제로 반환해 주는 함수이다. 데이터 영역이나 스택 영역에 할당되는 메모리의 크기는 컴파일 타임에 결정되어, 프로그램이 실행되는 내내(런타임 중) 고정된다. 하지만, 메모리의 동적 할당으로 힙 영역에 생성되는 메모리의 크기는 프로그램이 실행되는 내내(런타임 중) 변동된다. 따로 free() 함수를 통해 사용하지 않는 할당받은 메모리의 공간을 해제 해줘야 한다. 사용이 끝난 메모리를 해재하지 않으면, 메모리 부족현상이 발생하는데 그게 바로 메모리 누수(momey leak)이다. GC의 편리함을 새삼 다시 한번 느낄 수 있는 대목 위의 코드가 동작하는 과정을 간략하게 그림으로 표현한것 SP: 스택 프레임의 최상단을 가리키는 포인터 높은 주소에서 SP까지가 데이터가 채워진 부분, SP부터 스택 프레임의 마지막 주소까지는 비워져 있는 부분 PC: Text(CODE)영역에서 컴파일 되어 실행되는 코드의 주소를 한줄 씩 가리키는 주소 레지스터Heap Overflow 힙 오버플로(heap overflow)는 힙 데이터 영역에서 발생하는 버퍼 오버플로의 한 종류이다.(위키백과)DATA BSS: 초기화되지 않은 전역변수를 저장하는데 사용 DATA(GVAR): 초기값을 0이 아닌 특정한 값으로 지정한 경우 이곳에 저장Reference메모리의 동적 할당" }, { "title": "(CS)스레드", "url": "/posts/(CS)%EC%8A%A4%EB%A0%88%EB%93%9C/", "categories": "CS", "tags": "CS", "date": "2022-08-06 23:26:00 +0900", "snippet": "스레드 (Thread)스레드란? Light Weight Process 라고도 한다. 하나의 프로세스에 여러개의 스레드를 생성할 수 있다. 스레드들은 동시에 실행이 가능하다. 프로세스 안에 있으므로, 프로세스의 데이터를 모두 접근할 수 있다.멀티 스레드 이미지 출처: https://www.fun-coding.org/thread.html Thr...", "content": "스레드 (Thread)스레드란? Light Weight Process 라고도 한다. 하나의 프로세스에 여러개의 스레드를 생성할 수 있다. 스레드들은 동시에 실행이 가능하다. 프로세스 안에 있으므로, 프로세스의 데이터를 모두 접근할 수 있다.멀티 스레드 이미지 출처: https://www.fun-coding.org/thread.html Thread는 각기 실행이 가능한 Stack이 존재한다. 소프트웨어 병행작업 처리를 위해 Multi Thread를 사용한다. 멀티 코어의 활용도를 높인다.스레드의 장점 사용자에 대한 응답성 향상 웹 서버와 같이 사용자의 요청에 따라 빠르게 응답을 줘야하는 상황에서 사용된다. 자원을 공유하여 효율적이다. IPC기법과 같이 프로세스간 자원 공유를 위한 번거로운 작업이 필요없다. 프로세스 안에 있으므로, 프로세스의 데이터에 모두 접근이 가능하다. 스레드의 단점 이미지 출처: https://www.fun-coding.org/thread.html 스레드 중 한 스레드만 문제가 있어도, 전체 프로세스가 영향을 받는다.Thread vs Process 이미지 출처: https://www.fun-coding.org/thread.html 프로세스는 독립적, 스레드는 프로세스의 서브셋이다. 프로세스는 각각 독립적인 자원을 같는다, 스레드는 프로세스 자원을 공유 프로세스는 자신만의 주소영역을 가진다, 스레드는 주소 영역을 공유 프로세스간의 통신은 IPC기법을 활용해야한다. 스레드는 필요 없다.동기화 이슈 동기화: 작업들 사이에 실행 시기를 맞추는것 여러 스레드가 동일한 자원에 접근시 동기화 이슈가 발생할 수 있다. 동일 자원을 여러 스레드가 동시에 수정시, 각 스레드의 결과에 영향을 준다. 동기화 해결 방안(Mutual exclusion)import threadingg_count = 0def thread_main(): global g_count for i in range(1000000): g_count = g_count + 1threads = []for i in range(50): th = threading.Thread(target=thread_main) threads.append(th)for th in threads: th.start()for th in threads: th.join()print(\"g_count = \", g_count) range값이 10000정도 일때는 예상하는 값인 500000이 나오지만, 100000이 넘어서는 순간 전혀 예상하지 못한 값이 출력된다. 여러 스레드가 동일한 자원에 접근하여, 작업을하는 도중 동기화로 인한 문제가 발생되어 예상한 값과는 전혀 다른 값이 출력된다.import threadingg_count = 0def thread_main(): global g_count lock.acquire() for i in range(100000): g_count = g_count + 1 lock.release()lock = threading.Lock()threads = []for i in range(50): th = threading.Thread(target=thread_main) threads.append(th)for th in threads: th.start()for th in threads: th.join()print(\"g_count = \", g_count) mutual exclusion(상호 배제)을 활용하여, 동기화 이슈를 해결 lock.acquire(): 작업이 종료되기 전까지 다른 스레드가 공유 데이터에 접근하는것을 막아준다. lock.release(): lock을 해제 상호배제: 동시 프로그래밍에서 공유 불가능한 자원의 동시 사용을 피하기 위해 사용되는 알고리즘, 임계 구역으로 불리는 코드 영역에 의해 구현된다. 임계 자원을 처리하는 핵심 코드를 임계 구역이라 하며, 이걸 한번에 하나의 작업만을 가능하도록 지정하는것 range의 값이 커지더라도 동기화로 인한 이슈가 해결되어, 원하는 결과값을 얻을 수 있게된다.Mutex와 Semaphore Critical Section(임계 구역)에 대한 접근을 막기 위해 LOCKING 메커니즘이 필요 Mutex: 임계구역에 하나의 스레드만 들어갈 수 있다. Semaphore: 임계구역에 여러 스레드가 들어갈 수 있다. counter를 두어 동시에 리소스에 접근 가능한 스레드 수를 제어 교착상태(Deadlock)와 기아상태(Starvation)교착상태란? 무한 대기 상태: 두개 이상의 작업이 서로 상대방의 작업이 끝나기 만을 기다리고 있기 때문에, 다음 단계로 진행하지 못하는 상태 배치 처리 시스템에서는 일어나지 않는 문제, 프로세스와 스레드 둘 다 이와 같은 상태가 일어날 수 있다. 여러 프로세스가 동일한 자원에 대해 점유를 요청할 때 발생교착상태 발생 조건 다음 네 가지 조건이 모두 성립될 때, 교착상태 발생 가능성이 있다. 상호배제(Nutual exclusion): 프로세스들이 필요로 하는 자원에 대해 배타적인 통제권을 요구한다. 점유대기(Hold and wait): 프로세스가 할당된 자원을 가진 상태에서 다른 자원을 기다린다. 비선점(No preemption): 프로세스가 어떤 자원의 사용을 끝낼 때까지 그 자원을 뺏을 수 없다. 순환대기(Circular wait): 각 프로세스는 순환적으로 다음 프로세스가 요구하는 자원을 가지고 있다. 교착상태 해결 방법 가장 중요한 핵심은 조건의 일부가 성립이 안되게끔 만들어주는 것이 해결 방법의 가장 중요한 핵심기아상태란? 특정 프로세스의 우선순위가 낮아서 원하는 자원을 계속 할당 받지 못하는 상태 기아상태는 여러 프로세스가 부족한 자원을 점유하기 위해 경쟁할 때, 특정 프로세스에 영원히 자원이 할당되지 않는 경우를 말한다.기아상태 해결 방안 우선 순위 변경 프로세스의 우선순위를 수시로 변경하여, 각 프로세스가 높은 우선 순위를 가질 기회를 부여하면 된다.Reference스레드와 동기화" }, { "title": "(Spring)필터와 인터셉터", "url": "/posts/(Spring)%ED%95%84%ED%84%B0%EC%99%80-%EC%9D%B8%ED%84%B0%EC%85%89%ED%84%B0/", "categories": "Spring", "tags": "Spring", "date": "2022-07-26 22:29:00 +0900", "snippet": "필터와 인터셉터필터필터란? DispatcherServlet에 요청이 전달되기 전/후에 url 패턴에 맞는 모든 요청에 대 부가작업을 처리할 수 있는 기능을 제공하는 J2EE 표준 스팩 기능 DispatcherServlet이 Spring에 가장 앞단에 존재하는 Controller 이기 때문에 필터는 스프링의 밖에서 처리가 된다. 스프링 컨테이너에서...", "content": "필터와 인터셉터필터필터란? DispatcherServlet에 요청이 전달되기 전/후에 url 패턴에 맞는 모든 요청에 대 부가작업을 처리할 수 있는 기능을 제공하는 J2EE 표준 스팩 기능 DispatcherServlet이 Spring에 가장 앞단에 존재하는 Controller 이기 때문에 필터는 스프링의 밖에서 처리가 된다. 스프링 컨테이너에서 관리되는 것이 아니라 톰캣과 같은 웹 컨테이너 안에서 관리된다.필터의 메서드import javax.servlet.Filter; //Filter라는 이름을 가진 인터페이스가 몇개 더 있다. 헤깔리지말고 이걸 import해야한다.public class FirstFilter implements Filter {\t@Override public void init(FilterConfig filterConfig) throws ServletException { ... } @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {} @Override public void destroy() { ... } import: javax.servlet.Filter init: init 메서드는 필터 객체를 초기화하고 서비스에 추가하는 기능을 하는 메서드, 웹 컨테이너가 1회 init 메서드를 호출하여 필터 객체를 초기화 하면 이후의 요청들은 doFilter를 통해 처리된다. doFilter: URL 패턴에 맞는 모든 HTTP 요청이 디스패처 서블릿으로 전달되기 전에 웹 컨테이너에 의해 실행되는 메서드, chain.doFilter() 전/후에 작성되어 있는 필요한 로직을 넣어줌으로 원하는 처리를 진행할 수 있다. - 파라미터 - FilterChain: FilterChain의 doFilter를 통해 다음 대상으로 요청을 전달 destroy: 필터 객체를 서비스에서 제거하고 사용하는 자원을 반환하기 위한 메서드, 웹서버에 의해 1번 호출되며 이후 doFilter에 의해 처리되지 않는다.필터 Config 예전에는 필터가 스프링 컨테이너에서 관리되는 것이 아니라 Bean으로 등록하는게 불가능 했다고 한다. 하지만 지금은 Bean으로 등록이 가능하며, 더욱 편리하게 사용할 수 있게 되었다.public class MyWebApplicationInitializer extends AbstractAnnotationConfigDispatcherServletInitializer { public void onStartup(ServletContext servletContext) throws ServletException { \tsuper.onStartup(servletContext); \tservletContext.addFilter(\"FirstTestFilter\", DelegatingFilterProxy.class); }} Spring에서 Filter를 등록하는 방법@Configurationpublic class MvcConfiguration implements WebMvcConfigurer { @Bean public FilterRegistrationBean&lt;FirstTestFilter&gt; firstFilterRegister() { FilterRegistrationBean&lt;FirstTestFilter&gt; registrationBean = new FilterRegistrationBean&lt;&gt;(new FirstTestFilter()); registrationBean.setOrder(1); return registrationBean; } @Bean public FilterRegistrationBean&lt;SecondTestFilter&gt; secondFilterRegister() { FilterRegistrationBean&lt;SecondTestFilter&gt; registrationBean = new FilterRegistrationBean&lt;&gt;(new SecondTestFilter()); registrationBean.setOrder(2); return registrationBean; }} Spring Boot에서 Filter를 등록하는 방법 여러개의 필터를 사용할때는 setOrder() 를 사용해서 순서를 정해 줄 수 있다.필터 이미지 필터의 작동 과정을 이미지로 표현인터셉터인터셉터란? Spring이 제공하는 기술, 디스패처 서블릿이 컨트롤러를 호출하기 전과 후에 요청과 응답을 참조하거나 가공할 수 있는 기능을 제공인터셉터의 메서드public class FirstTestInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { }} imporit: org.springframework.web.servlet preHandle: 컨트롤러가 호출되기 전에 실행되며, 컨트롤러 이전에 처리해야하는 전처리 작업이나 요청정보를 가공, 추가하는데 사용된다. postHandle: 컨트롤러 호출된 후에 실행된다. 컨트롤러 이후에 처리해야 하는 후처리 작업이 있을때 사용 afterCompletion: 모든 뷰에서 최종 결과를 생성하는 일을 포함, 모든 작업이 완료된 후에 실행된다. 요청 처리 중에 사용한 리소스를 반환할 때 사용하기에 적합하다.인터셉터 Config@Configurationpublic class MvcConfiguration implements WebMvcConfigurer { @Override public void addInterceptors(InterceptorRegistry registry) {\t\tregistry.addInterceptor(interceptor) .addPathPatterns(\"/\") .addPathPatterns(\"/member/\") .excludePathPatterns(\"/login\").order(1); registry.addInterceptor(subInterceptor) .addPathPatterns(\"/\") .excludePathPatterns(\"/login2\").order(2);\t}} addPathPatterns: 인터셉터가 동작할 URL 패턴 excluedPathPatterns: 인터셉터가 동작하지 않을 URL 패턴 order: 다중 인터페이스 사용 시 순서를 정해준다.인터셉터 이미지 인터셉터가 위치하는 곳과 처리순서를 이미지로 간략하게 표현필터(Filter)와 인터셉터(Interceptor) 차이 및 용도 대상 필터(Filter) 인터셉터(Intercepter) 관리되는 컨테이너 웹 컨테이너 스프링 컨테이너 Request/Response&lt;/br&gt;객체 조각 가능 여부 가능 불가능 용도 - 공통된 보안 및 인증/인가 관련 작업- 모든 요청에 대한 로깅 또는 감사- 이미지/데이터 압축 및 문자열 인코딩- Spring과 분리되어야 하는 기능 - 세부적인 보안 및 인증/인가 공통작업- API 호출에 대한 로깅 또는 감사- Controller로 넘겨주는 데이터 가공 Request/Response 객체 조작 가능 여부 필터는 Request/Response를 조작할 수 있다.public class FirstTestFilter implements Filter { private final Logger log = LoggerFactory.getLogger(this.getClass()); @Override public void init(FilterConfig filterConfig) throws ServletException { log.info(\"FirstFilter 생성: {}\", this.getClass()); } @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { log.info(\"FirstFilter 실행: {}\", this.getClass()); chain.doFilter(request, response); ((HttpServletResponse) response).sendError(HttpServletResponse.SC_BAD_REQUEST); // response를 조작하여, 어떤 request가 들어오던 400을 반환 log.info(\"FirstFilter 종료: {}\", this.getClass()); } @Override public void destroy() { log.info(\"FirstFilter 삭제: {}\", this.getClass()); }} 위에 보이는 코드처럼 response를 조작하여, 어떤 request가 들어오던 400을 반환시킬 수 있다. 이렇게 response와 request를 조작할 수 있는것이 인터셉터와 가장 큰 차이점이다. 인터셉터는 필터와 처리 과정이 다르기 때문에 Request/Response객체를 조작하여 넘겨줄수 없다. 인터셉터는 디스패처 서블릿이 여러 인터셉터의 목록을 가지고, 반복문을 통해 순차적으로 실행시킨다. 그 후 true를 반환하면 다음 인터셉터가 실행되거나 컨트롤러로 요청이 전달된다.(false가 반환되면 요청이 중단된다.) public class FirstTestInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { if (...) { ... return true; } return false; }} 위에 보이는것처럼 true와 false 두가지만 반환이 가능하고, 그 결과로 다음 인터셉가 실행되거나, 컨트롤러로 요청이 전달되기 때문에 request나 response의 조작이 불가능하다.필터의 용도 및 예시- 공통된 보안 및 인증/인가 관련 작업- 모든 요청에 대한 로깅 또는 감사- 이미지/데이터 압축 및 문자열 인코딩- Spring과 분리되어야 하는 기능 필터에서는 기본적으로 스프링과 무관하게 전역적으로 처리해야 하는 작업들을 처리할 수 있다. 이미지나 데이터의 압축, 문자열 인코딩과 같이 웹 애플리케이션에 전박적으로 사용되는 기능을 구현하기 좋다.인터셉터의 용도 및 예시- 세부적인 보인 및 인증/인가 공통작업- API 호출에 대한 로깅 또는 감사- Controller로 넘겨주는 데이터의 가공 클라이언트의 요청과 관련되어 전역적으로 처리해야 하는 작업들을 처리할 수 있다. 특정 그룹의 사용자마다 사용할 수 있는 기능을 나눌때 사용하면 좋다. JWT토큰 정보를 파싱해서 컨트롤러에 사용자의 정보를 제공하는 등 컨트롤러로 넘겨주기 위한 정보를 가공하기 용이하다.REFRENCE[Spring] 필터(Filter) vs 인터셉터(Interceptor) 차이 및 용도 - (1)spring - 스프링에서의 필터 개념 및 예제" }, { "title": "(JWT)JWT", "url": "/posts/(JWT)JWT/", "categories": "JWT", "tags": "JWT", "date": "2022-07-25 22:33:00 +0900", "snippet": "⁉️ JWT란? RFC7519 웹 표준으로 지정 JSON 객체를 사용해서 토큰 자체에 정보들을 저장하고 있는 Web Token이다.🔍 JWT의 구성Header Signature를 해싱하기 위한 알고리즘 정보가 담겨있다.{\t\"alg\" : \"HS256\",\t\"typ\" : \"JWT\"} alg: 서명 알고리즘 작성 typ: 토큰 타입을 명시Paylo...", "content": "⁉️ JWT란? RFC7519 웹 표준으로 지정 JSON 객체를 사용해서 토큰 자체에 정보들을 저장하고 있는 Web Token이다.🔍 JWT의 구성Header Signature를 해싱하기 위한 알고리즘 정보가 담겨있다.{\t\"alg\" : \"HS256\",\t\"typ\" : \"JWT\"} alg: 서명 알고리즘 작성 typ: 토큰 타입을 명시Payload 서버와 클라이언트가 주고받는, 시스템에서 실제로 사용될 정보에 대한 내용들을 담고있다.{\t\"sub\" : \"1234567890\",\t\"name\" : \"John Doe\",\t\"admin\" : true} 토큰에 담겨져 있는 데이터를 클레임이라고 한다. 클레임 타인수락률 iss(issuer) JWT를 발행하는 주체를 나타냄 sub(subject) JWT의 주제를 나타냄 aud(audience) JWT발급의 대상자를 나타냄 exp(expiration time) JWT의 만료 날짜/시간을 나타냄 nbf(not before) JWT사용 시작 날짜/시간을 나타냄 iat(issued at) JWT가 발행된 날짜/시간을 나타냄 jti(JWT id) JWT에 대한 고유 식별자로, JWT 복사 방지 Signatuer 토큰의 유효성 검증을 위한 문자열 문자열을 통해 해당 토큰이 유효한 토큰인지를 검증한다.HMACSHA256(\tbase64UrlEncode(header) + \".\" +,\tbase64UrlEncode(payload),\tSecretkey)👀 JWT의 장단점JWT의 장점 중앙의 인증서버, 데이터 스토어에 대한 의존성이 없어, 시스템을 수평적으로 확장하는데 유리하다. 사용이 쉽고, 간단하여 사이드 프로젝트에서 사용하기 좋다. Base64 URL Safe Encoding &gt; URL, Cookie, Header 모두 사용 가능JWT의 단점 Payload의 정보가 많아지면 네트워크 사용량이 증가(트래픽⬆️ ), 데이터의 설계 고려가 필요하다. 토큰이 클라이언트에 저장, 서버에서 클라이언트의 토큰을 조작할 수 없다.🚫 세션과 토큰세션 세션 기반 인증의 기본적인 프로세스 서버 측에 클라이언트의 접속 상태를 저장토큰 토큰 기반 인증의 기본적인 프로세스 비밀키 또는 공개(개인) 키를 이용해 서명한 토큰을 클라이언트에 전달 데이터 요청 시 클라이언트는 토큰을 포함한 상태로 요청을 진행 서버는 토큰의 서명 값을 이용해 유효한 토큰인지 검증세션과 토큰의 차이점 정보 포함: 세션 값 자체에는 정보가 포함되어 있지 않다. 하지만, 토큰값에는 정보가 포함되어있다. 상태 정보 미저장: 세션 방식은 상태 정보를 서버 내에 저장. 하지만, 토큰은 서버에 클라이언트의 상태를 저장하지 않는 무상태성 방식 토큰에는 세션값에 없는 정보를 함께 포함하기 때문에 길이가 길다. -&gt; 정보가 너무 많으면 네트워크 사용량이 증가될 수 있다. 토큰 방식을 사용 시 서버에 정보를 저장할 필요가 없다. -&gt; 서버의 확장에 유리하다.📌 REFERENCEJwt.io" }, { "title": "(일일회고)22.07.20", "url": "/posts/(%EC%9D%BC%EC%9D%BC%ED%9A%8C%EA%B3%A0)22.07.20/", "categories": "일일회고", "tags": "일일회고", "date": "2022-07-20 23:55:00 +0900", "snippet": "일일회고👨‍💻오늘 한일 Unit Test 공부 issue-tracker 프로젝트 Label, Assignee CRUD API 개발 Label Service Test 😆좋았던 점 Unit Test 공부를 하면서, 그동안 해야하지 라고 생각만...", "content": "일일회고👨‍💻오늘 한일 Unit Test 공부 issue-tracker 프로젝트 Label, Assignee CRUD API 개발 Label Service Test 😆좋았던 점 Unit Test 공부를 하면서, 그동안 해야하지 라고 생각만 했던 테스트 진행을 할 수 있어 좋았다. 새로운걸 배우는건 늘 신기하고 재미있다. 🥺아쉬운 점 알고리즘 난 왜이렇게 어려운걸까 하기 싫어도 매일 한 문제 이상은 풀어보자.👨‍💻내일 할 일 issue-tracker 프로젝트 Label Service 제외한 나머지 Test 작성 로그인 한 유저에 대한 데이터만 해당 유저가 접근이 가능하도록 변경 알고리즘 1문제" }, { "title": "(TEST)UnitTest", "url": "/posts/(Test)UnitTest/", "categories": "TEST", "tags": "TEST", "date": "2022-07-20 23:21:00 +0900", "snippet": "UnitTest JUnit5, assertj-core 3.x 버전 기준Mockito@Mock mock 모의 객체 생성을 위한 어노테이션@InjectMocks 주입을 수행해야 하는 필드를 표시하기 위한 어노테이션@ExtendWith(MockitoExtension.class) @ExtendWith: JUnit4에서 사용되던 @RunWith ...", "content": "UnitTest JUnit5, assertj-core 3.x 버전 기준Mockito@Mock mock 모의 객체 생성을 위한 어노테이션@InjectMocks 주입을 수행해야 하는 필드를 표시하기 위한 어노테이션@ExtendWith(MockitoExtension.class) @ExtendWith: JUnit4에서 사용되던 @RunWith 를 대체하는 어노테이션, 테스트 확장을 위한 class 선언에 사용된다. MockitoExtension.class: @Mock 어노테이션으로 모의 객체를 생성하기 위해 선언 MockitoExtension.class BDDMockito학습 내용 BDD(Behavior-Driven Development) : 행위 주도 개발, 테스트 대상의 상태의 변화를 테스트 하는것이며 시나리오를 기반으로 테스트하는 패턴을 권장한다. 권장하는 기본 패턴은 given-when-then 구조를 가진다. Mockito 를 상속한 클래스(public class BDDMockito extends Mockito) given: 특정 상태에서 출발하여 when: 어떤 상태 변화를 가했을 때 then: 기대하는 상태로 완료되어야 한다.@Testvoid given_when_then() throws Exception { //given Long articleId = 1L; ArticleComment expected = createArticleComment(\"content\"); given(articleCommentRepository.findByArticle_Id(articleId)).willReturn(List.of(expected)); //when Page&lt;ArticleCommentDto&gt; actual = sut.searchArticleComment(articleId); //then assertThat(actual) .hasSize(1) .first() .hasFieldOrPropertyWithValue(\"content\", expected.getContent()); then(articleCommentRepository).should().findByArticle_Id(articleId);} 게시글 Id로 게시글에 작성되어있는 댓글 리스트를 반환하는 간단한 테스트 예제 given: 1L 의 아이디를 가지는 게시글에 댓글 이 작성 되어 있는 상태를 만들고, 댓글 리포지토리에서 해당 게시글 아이디를 가지고 댓글을 찾은 상태에서 출발 when: searchArticleComment() 해당 메서드로 게시글 아이디에 해당하는 댓글을 찾았을때 then: content 라는 내용을 가지는 댓글이 반환되어야 한다. hasFieldOrPropertyWithValue : 실제 개체가 지정된 값을 가진 지정된 필드 또는 속성을 가지고 있는지 확인(content 라는 값을 가진 Object 가 있는지 확인) hasFieldOrPropertyWithValue Guide then(articleCommentRepository).should().findByArticle_Id(articleId) : 댓글 리포지토리에서 findByarticle_Id() 라는 매서드가 동작 해야한다. 주의할 점 Mockito Strict Stubbing and The UnnecessaryStubbingException@DisplayName(\"레이블 정보를 입력하면, 해당 레이블을 수정한다.\")@Testvoid givenLabelInfo_whenUpdatingLabel_thenUpdatedLabel() throws Exception { //given Long labelId = 1L; String oldTitle = \"labelTitle1\"; String updateTitle = \"labelTitle2\"; Label label = createLabel(labelId, oldTitle); RequestLabelDto dto = createRequestLabelDto(updateTitle); given(labelRepository.findById(labelId)).willReturn(Optional.of(label)); //when label.update(dto); //then assertThat(label.getTitle()) .isNotEqualTo(oldTitle) .isEqualTo(updateTitle); then(labelRepository).should().findById(labelId);} 에러 코드Wanted but not invoked:labelRepository.findById(1L);-&gt; atteam20.issuetracker.service.LabelServiceTest.givenLabelInfo_whenUpdatingLabel_thenUpdatedLabel(LabelServiceTest.java:20)Actually, there were zero interactions with this mock. 에러 문구 에러 원인 : Mockito 2.+ 새로 추가된 스터빙의 관한 이유로, 사용되지 않은 메서드가 given또는 then에 존재 하는 경우 발생한다. 업데이트 하는 로직이 label 안에 존재하긴 하나 given 에서 생성한 label 을 가지고 바로 update 를 실행하면서, labelRepository 를 거치지 않아 에러가 발생 하였다. 테스트 하는 로직이 시나리오에 맞지 않아 발생하거라 생각하면 조금 더 쉽게 원인을 알 수 있다. 위에 에러에 관한 Bdeldung 글 @DisplayName(\"레이블 정보를 입력하면, 해당 레이블을 수정한다.\")@Testvoid givenLabelInfo_whenUpdatingLabel_thenUpdatedLabel() throws Exception { //given Long labelId = 1L; String oldTitle = \"labelTitle1\"; String updateTitle = \"labelTitle2\"; Label label = createLabel(labelId, oldTitle); RequestLabelDto dto = createRequestLabelDto(updateTitle); given(labelRepository.findById(labelId)).willReturn(Optional.of(label)); //when labelRepository.findById(labelId).orElseThrow(() -&gt; { throw new IllegalArgumentException(\"존재하지 않는 Label 입니다.\"); }).update(dto); //then assertThat(label.getTitle()) .isNotEqualTo(oldTitle) .isEqualTo(updateTitle); then(labelRepository).should().findById(labelId);} 수정한 코드 : labelRepository 에서 labelId에 해당하는 Label 을 찾아서 Update 로직을 수행하여, findById() 메서드를 사용하게 되서 에러가 해결되었다.REFERENCEMockito DocsJUnit 5 User GuideAssertJ Docs" }, { "title": "(일일회고)22.07.14", "url": "/posts/(%EC%9D%BC%EC%9D%BC%ED%9A%8C%EA%B3%A0)22.07.14/", "categories": "일일회고", "tags": "일일회고", "date": "2022-07-14 23:11:00 +0900", "snippet": "👨‍💻오늘 한일 코테 대비 문제 풀이 자꾸 보다보니 풀리긴 한다 ㅠㅠ issue-tracker 프로젝트 4일차 토큰 구별은 매우 쉽게 해결 issue 생성 API는 JPA 매핑 문제로 조금 애를 먹고있다. 😆좋았던 점 알고리즘 문제를 하나 이상 해결해서 기분이 좋았다. ...", "content": "👨‍💻오늘 한일 코테 대비 문제 풀이 자꾸 보다보니 풀리긴 한다 ㅠㅠ issue-tracker 프로젝트 4일차 토큰 구별은 매우 쉽게 해결 issue 생성 API는 JPA 매핑 문제로 조금 애를 먹고있다. 😆좋았던 점 알고리즘 문제를 하나 이상 해결해서 기분이 좋았다. 매우 쉬운 문제였지만, 그래도 점차 나아지고 있는거 같아 의지가 생긴다. issue-tracker 프로젝트를 진행하면서, 많은걸 배우고 있는거 같다. 사실 공부한 내용을 정리해야하는데 시간이 부족하다.(핑계..) 🥺아쉬운 점 어제 회고 작성을 못했다. 새로운 강의를 듣고있는데, 내가 모르는게 아직도 너무 많다.👨‍💻내일 할 일 issue-tracker 프로젝트 5일차 Entity 매핑 다시 생각해보기 " }, { "title": "(일일회고)22.07.12", "url": "/posts/(%EC%9D%BC%EC%9D%BC%ED%9A%8C%EA%B3%A0)22.07.12/", "categories": "일일회고", "tags": "일일회고", "date": "2022-07-12 23:56:00 +0900", "snippet": "👨‍💻오늘 한일 JPA 기본편 강의 복습 고급 매핑까지 코드스쿼드 코테 대비 1일차 문제 풀이 issue-tracker 프로젝트 2일차😆좋았던 점 오늘은 사실 여러모로 아쉬운점이 많은 날이다.🥺아쉬운 점 issue-tracker 프로젝트를 진행하면서, 기능 구현을 하나씩 할때마다 크고, 작은 문제가 자꾸 발생하여 예...", "content": "👨‍💻오늘 한일 JPA 기본편 강의 복습 고급 매핑까지 코드스쿼드 코테 대비 1일차 문제 풀이 issue-tracker 프로젝트 2일차😆좋았던 점 오늘은 사실 여러모로 아쉬운점이 많은 날이다.🥺아쉬운 점 issue-tracker 프로젝트를 진행하면서, 기능 구현을 하나씩 할때마다 크고, 작은 문제가 자꾸 발생하여 예상보다 프로젝트 진도가 많이 느려 아쉽다. 코드스쿼드를 수료했지만, 프로젝트를 하면서 아직 내가 많이 부족하다는걸 많이 느끼게된다. 코드스쿼드 코테 대비가 시작되어 1일차 문제를 풀었으나, 두 문제중에 두개다 시간안에 해결하지 못했다. 조금은 충격이였다.💧👨‍💻내일 할 일 오늘 해결하지 못한 알고리즘 문제 재 도전 코테 대비 2일차 문제 풀이 issue-tracker 프로젝트 3일차 issue 생성 API 만들기 accessToken과 refreshToken을 구별하는 로직 추가 ec2에서 redis를 연결하지 못하는 이슈 해결 " }, { "title": "(일일회고)22.07.11", "url": "/posts/(%EC%9D%BC%EC%9D%BC%ED%9A%8C%EA%B3%A0)22.07.11/", "categories": "일일회고", "tags": "일일회고", "date": "2022-07-12 00:57:00 +0900", "snippet": "👨‍💻오늘 한일 JPA 기본편 강의 복습 연관관계 매핑 까지 듣기 꾸풀러 알고리즘 스터디 issue-tracker 프로젝트 1일차😆좋았던 점 이전에 코쿼에서 진행했던 마지막 프로젝트인 issue-tracker를 추가적으로 진행하기로한 첫날이다.🥺아쉬운 점 저녁에 급한 일정이 생겨 학습을 많이 진행하지 못했다.👨‍💻내...", "content": "👨‍💻오늘 한일 JPA 기본편 강의 복습 연관관계 매핑 까지 듣기 꾸풀러 알고리즘 스터디 issue-tracker 프로젝트 1일차😆좋았던 점 이전에 코쿼에서 진행했던 마지막 프로젝트인 issue-tracker를 추가적으로 진행하기로한 첫날이다.🥺아쉬운 점 저녁에 급한 일정이 생겨 학습을 많이 진행하지 못했다.👨‍💻내일 할 일 JPA 기본편 강의 듣기 고급 매핑까지 꾸풀러 알고리즘 스터디 코드스쿼드 알고리즘 대비 첫날" }, { "title": "(Algorithm)트리 순회", "url": "/posts/(Algorithm)%ED%8A%B8%EB%A6%AC-%EC%88%9C%ED%9A%8C/", "categories": "Algorithm", "tags": "Algorithm", "date": "2022-05-25 03:16:00 +0900", "snippet": "트리 순회전위 순회 부모노드 -&gt; 왼쪽 자식 노드 -&gt; 오른쪽 자식 노드 순으로 순회중위 순회 왼쪽 자식 노드 -&gt; 부모 노드 -&gt; 오른쪽 자식 노드 순으로 순회후위 순회 왼쪽 자식 노드 -&gt; 오른쪽 자식 노드 -&gt; 부모 노드 순으로 순회이진트리순회 구현class Node { int data; Node ...", "content": "트리 순회전위 순회 부모노드 -&gt; 왼쪽 자식 노드 -&gt; 오른쪽 자식 노드 순으로 순회중위 순회 왼쪽 자식 노드 -&gt; 부모 노드 -&gt; 오른쪽 자식 노드 순으로 순회후위 순회 왼쪽 자식 노드 -&gt; 오른쪽 자식 노드 -&gt; 부모 노드 순으로 순회이진트리순회 구현class Node { int data; Node lt, rt; public Node(int value) { data = value; lt = rt = null; }}public class Main { Node root; public void dfs(Node root) { if (root == null) return; else { // System.out.println(\"root\") 전위순회 dfs(root.lt); // System.out.println(\"root\") 중위순회 dfs(root.rt); // System.out.println(\"root\") 후위순회 } } public static void main(String[] args) { Main tree = new Main(); tree.root = new Node(1);\t\ttree.root.lt = new Node(2); tree.root.rt = new Node(3); tree.root.lt.lt = new Node(4); tree.root.rt.rt = new Node(5); tree.root.rt.lt = new Node(6); tree.root.rt.rt = new Node(7); tree.dfs(tree.root); }} 재귀를 활용하여 이진 트리 순회를 구현 출력 하는 위치에 따라 전위, 중위, 후위 순회에 맞는 값이 출력된다.부분집합(DFS)public class SubsetDFS { static class Main { static int n; static int[] ch; public void solution(int l) { if (l == n + 1) { String tmp = \"\"; for (int i = 1; i &lt;= n; i++) { if (ch[i] == 1) { tmp += (i + \" \"); } } if (tmp.length() &gt; 0) { System.out.println(tmp); } } else { ch[l] = 1; solution(l + 1); ch[l] = 0; solution(l + 1); } } public static void main(String[] args) { Main main = new Main(); n = 3; ch = new int[n + 1]; main.solution(1); } }} DFS를 활용하여, 부분집합 구하기 알고리즘 예제" } ]
